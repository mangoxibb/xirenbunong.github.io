<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiren</title>
  
  <subtitle>谦谦君子，温润如玉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-02T09:27:22.565Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端三座大山详解</title>
    <link href="http://yoursite.com/2018/10/02/2018/10/three-mon/"/>
    <id>http://yoursite.com/2018/10/02/2018/10/three-mon/</id>
    <published>2018-10-01T16:00:00.000Z</published>
    <updated>2018-11-02T09:27:22.565Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 本篇文章详细阐述前端三座大山：作用域和闭包、原型和原型链、异步与单线程</p><p><a id="more"></a></p><h3>作用域和闭包</h3><ol><li>基本概念第一种说法：</li></ol><pre><code>JS 的闭包包含以下要点：    函数声明的时候，会生成一个独立的作用域    同一作用域的对象可以互相访问    作用域呈层级包含状态，形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；    另外子作用域会使用最近的父作用域的对象</code></pre><p>第二种说法：</p><pre><code>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数）</code></pre><ol start="2"><li><p>面试讲解流程</p><p>原因：从JS的执行开始讲、一个函数执行前后的内存回收过程，再阐述闭包形成的原因，这样又会导致什么问题，应该怎么解决。最后再讲有什么用途，或者说自己曾经有什么需求需要闭包来实现。这么一轮讲下来，会让面试官觉得这位同学至少对闭包是有研究了，而不是死记硬背了一些面试题之类的。</p></li></ol><pre><code>js的执行：    1.在js中定义的全局变量是不会被销毁的    2.但是在函数中定义的变量就不一定了        如果这个函数有被外部的变量引用就不会销毁，否则销毁闭包的使用场景：     (1)函数作为返回值return function(){}    (2)函数作为参数传递function(a, function(){})闭包最常见的例子(用途)：    计时器：        for(var i = 0; i &lt; 5; i++){            (function(i){                setTimeout(function(){                    console.log(i);                },1000);            })(i);        }        //0 1 2 3 4为什么这样打印出来的就不是5个5呢？    js是单线程的，(fn())，这样是一个立即执行函数，    将setTimeout放入立即执行函数中，    每次for循环都会执行这个立即执行函数，在内存中维持一次    1000毫秒后同时输出0 1 2 3 4如果你还是没有理解为什么这样写，看下面的例子更直观：    //声明，定义    function printTime(i){        setTimeout(function(){            console.log(i);        },1000);    }    //执行    for(var i = 0; i &lt; 5; i++){        printTime(i);    }</code></pre><ol start="3"><li>对比例题</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//无引用</span><br><span class="line">function a()&#123;</span><br><span class="line">　　var num = 10;</span><br><span class="line">　　return function()&#123;</span><br><span class="line">　　　　num ++;</span><br><span class="line">　　　　console.log(num);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">a()(); //11</span><br><span class="line">a()(); //11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//有引用</span><br><span class="line">function a()&#123;</span><br><span class="line">    var b = 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        b ++;</span><br><span class="line">        console.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = a(); //引用</span><br><span class="line">d();//1</span><br><span class="line">d();//2</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//非闭包</span><br><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;    //5 5 5 5 5</span><br><span class="line"></span><br><span class="line">//闭包</span><br><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">//0 1 2 3 4</span><br></pre></td></tr></table></figure></p><h3>原型和原型链</h3><ol><li></li></ol><h3>异步与单线程</h3><ol><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 本篇文章详细阐述前端三座大山：作用域和闭包、原型和原型链、异步与单线程&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端笔试面试考前速记</title>
    <link href="http://yoursite.com/2018/10/02/2018/10/face-to-face/"/>
    <id>http://yoursite.com/2018/10/02/2018/10/face-to-face/</id>
    <published>2018-10-01T16:00:00.000Z</published>
    <updated>2018-10-31T03:25:40.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 笔试面试考前速记</p><p><a id="more"></a></p><h3></h3><ol><li>数据类型</li></ol><pre><code>值类型(引用类型)：string,number,boolean,null,undefined,symbol引用类型： Function,Array,Object</code></pre><ol start="2"><li>typeof</li></ol><pre><code>Null        &quot;object&quot;   ***其他返回值均为小写</code></pre><ol start="3"><li>原型链</li></ol><pre><code>当试图得到对象某个属性时, 如果没有这个属性, 则会去它的__proto__中寻找,即等于在它的构造函数的显示原型去寻找, 如果没有, 构造函数的显示原型(Foo.prototype)可以看作一个对象, 故可以继续找对象的隐式原型。这种寻找方式就叫做原型链(即f.__proto__.__proto__)</code></pre><ol start="4"><li>闭包</li></ol><pre><code>闭包包含以下要点：（声明 -&gt; 独立作用域 -&gt; 相互访问 -&gt; 作用域链）1.函数声明的时候，会生成一个独立的作用域2.同一作用域的对象可以互相访问3.作用域呈层级包含状态，形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；另外子作用域会使用最近的父作用域的对象闭包的使用场景：(1)函数作为返回值return function(){}(2)函数作为参数传递function(a, function(){})闭包的优缺点：优点：     1.保护函数内的变量安全,加强了封装性     2.在内存中维持一个变量缺点：    内存浪费问题闭包实例：计时器如何理解计时器：由于js是单线程的，所以在执行for循环的时候定时器setTimeout被安排到任务队列中排队等待执行，而在等待过程中for循环就已经在执行，等到setTimeout可以执行的时候，for循环已经结束，i的值也已经编程5，所以打印出来五个5如何修改为正确的计时器：将setTimeout放入立即执行函数中，将for循环中的循环值i作为参数传递，100毫秒后同时打印出1 2 3 4 5</code></pre><ol start="5"><li>数组与字符串相互转换</li></ol><pre><code>split()字符串转数组 join()数组转字符串</code></pre><ol start="6"><li>跨域</li></ol><pre><code>JSONP : 客户端动态&lt;script&gt;,服务器端GET方法名date数据callback返回CORS  ：http请求和http响应加字段window.postMessage(message,targetOrigin)location.hash + iframe ：a到b, b到c, c到a。</code></pre><ol start="7"><li>性能优化</li></ol><pre><code>减少页面体积 ：静态资源的压缩合并、静态资源缓存(本地缓存)、使用CDN优化页面渲染 ：CSS放在前面, JS放在后面、懒加载、减少DOM查询, 减少DOM操作尽早执行操作</code></pre><ol start="8"><li>TCP和UDP</li></ol><pre><code>TCP和UDP区别？连接与无连接、                可靠与不可靠、                实时性、                      点到点与多对多、              资源要求            </code></pre><ol start="9"><li>GET和POST</li></ol><pre><code>信息获取和修改资源地址栏和表单数据量限制</code></pre><ol start="10"><li>排序</li></ol><pre><code>快速排序大于基准数放右边小于基准数放左边每经过一趟快排，轴点元素都必然就位，也就是说，一趟下来至少有1个元素在其最终位置，所以考察各个选项，看有几个元素就位即可。插入排序i = 0时第一个数为基准数放入数组i = 1时第二个数与第一个数比较放入合适的位置i = 2时第三个数与前两个数比较放入合适的位置选择排序在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</code></pre><ol start="11"><li>cookie、sessionStorage和localStorage</li></ol><pre><code>cookie:存储量太小, 只有4KB所有http请求都带着, 影响获取资源效率API简单, 需要封装才能用sessionStorage, localStorage：存储量5M不是每次在请求API易用</code></pre><ol start="12"><li>url到得到html的详细过程</li></ol><pre><code>网络层面：DNS解析TCP连接 三次握手发送HTTP请求服务器处理请求并返回HTTP报文浏览器解析渲染页面连接结束前端层面：根据HTML结构生成DOM Tree根据CSS生成CSSOM将DOM和CSSOM整合形成RenderTree根据RenderTree开始渲染和展示遇到&lt;script&gt;时, 会执行并阻塞渲染</code></pre><ol start="13"><li>继承的例子<br>(要点：<br>1.构造函数的属性、函数定义用this<br>2.子构造函数 点 prototype = new 父构造函数<br>3.实例化子构造函数的对象)</li></ol><pre><code>// 动物function Animal() {    this.eat = function () {        console.log('animal eat')    }}// 狗function Dog() {    this.bark = function () {        console.log('dog bark')    }}Dog.prototype = new Animal()     ***// 哈士奇var 二狗子 = new Dog()</code></pre><ol start="14"><li>ajax请求</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(要点：</span><br><span class="line">1.创建一个XMLHttpRequest对象</span><br><span class="line">2.open函数</span><br><span class="line">3.对象 点 onreadystate</span><br><span class="line">4.监听状态和状态码</span><br><span class="line">5.send函数</span><br><span class="line">或者：</span><br><span class="line">1.请求方式请求路径请求数据请求数据类型</span><br><span class="line">2.成功回调函数失败回调函数)</span><br><span class="line"></span><br><span class="line">//new一个XMLHttpRequest对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">//发送请求, 请求方法get, 请求地址api, 异步请求false</span><br><span class="line">xht.open(&quot;GET&quot;, &quot;/api&quot;, false);</span><br><span class="line">//一直监听readyState状态码的变化</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    //4表示已经返回, 200表示返回成功</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            //执行事件, responseText是服务端返回的内容</span><br><span class="line">            alter(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将信息发送到服务器</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><ol start="15"><li>数组去重</li></ol><pre><code>indexOf()方法会对非数组元素返回-1indexOf()方法只返回该元素第一次出现的索引值排序数组与新数组最后一个元素进行比较ES6 set : [...new Set(arr)]</code></pre><ol start="16"><li>ES6</li></ol><pre><code>let和const：    let定义变量，const定义常量(比如PI)    不能重复定义(避免造成变量命名冲突)    块级作用域({只在这里面生效}、for循环里面let i=0)    不存在变量提升(指的是先使用再声明)箭头函数：    参数 =&gt; 表达式/语句    继承外层作用域    不能用作构造函数    没有prototype属性</code></pre><ol start="17"><li>非技术问题</li></ol><pre><code>面试结束后，面试官问还有什么想要了解的？技术面试官：1. 公司项目中运用到的技术；2. 如果自己有幸被贵公司选中，需要掌握什么技术，需要掌握到什么程度，大概需要在什么时间范围内；3. 公司业务流程和团队建设等等；HR：1. 公司福利；2. 假期和加班；3. 薪资</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 笔试面试考前速记&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试手撕代码总结</title>
    <link href="http://yoursite.com/2018/09/04/2018/09/WEcode/"/>
    <id>http://yoursite.com/2018/09/04/2018/09/WEcode/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2018-10-31T01:28:04.173Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 前段面试常考的手撕代码题</p><p><a id="more"></a></p><h4>1. JavaScript代码</h4><ol><li><p>继承的例子(要点：1.构造函数的属性、函数定义用this2.子构造函数 点 prototype = new 父构造函数3.实例化子构造函数的对象)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 动物</span><br><span class="line">function Animal() &#123;</span><br><span class="line">    this.eat = function () &#123;       //this的用法, 在构造函数中</span><br><span class="line">        console.log(&apos;animal eat&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 狗</span><br><span class="line">function Dog() &#123;</span><br><span class="line">    this.bark = function () &#123;       //this的用法, 在构造函数中</span><br><span class="line">        console.log(&apos;dog bark&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = new Animal()     ***</span><br><span class="line">// 哈士奇</span><br><span class="line">var husky = new Dog();</span><br><span class="line">husky.eat();         //animal eat</span><br></pre></td></tr></table></figure></p></li><li><p>ajax请求<br>(要点：1.创建一个XMLHttpRequest对象<br>2.open函数<br>3.对象 点 onreadystate<br>4.监听状态和状态码<br>5.send函数<br>或者：<br>1.请求方式请求路径请求数据请求数据类型<br>2.成功回调函数失败回调函数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//new一个XMLHttpRequest对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">//发送请求, 请求方法get, 请求地址api, 异步请求false</span><br><span class="line">xht.open(&quot;GET&quot;, &quot;/api&quot;, false);</span><br><span class="line">//一直监听readyState状态码的变化</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    //4表示已经返回, 200表示返回成功</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            //执行事件, responseText是服务端返回的内容</span><br><span class="line">            alter(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将信息发送到服务器</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">request : function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type        : param.method  || &apos;get&apos;,   //请求方式</span><br><span class="line">        url         : param.url     || &apos;&apos;,      //请求路径</span><br><span class="line">        dataType    : param.type    || &apos;json&apos;,  //请求数据类型</span><br><span class="line">        data        : param.data    || &apos;&apos;,      //请求数据</span><br><span class="line">        success     : function(res)&#123;</span><br><span class="line">            //请求成功</span><br><span class="line">        &#125;,</span><br><span class="line">        error       : function(err)&#123;</span><br><span class="line">            //请求失败</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>数组去重<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路1：定义一个新数组为空，indexOf()方法是获取元素在数组中的所有，</span><br><span class="line">如果没有该元素，返回-1。所以原数组每个元素凡是不在新数组中的，</span><br><span class="line">都使用push()方法加入新数组。</span><br><span class="line">(本思路关键点在于：indexOf()方法会对非数组元素返回-1)</span><br><span class="line">function mvRepeat(arr)&#123;</span><br><span class="line">    var tempArr = [];</span><br><span class="line">    for(var i=0, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">        if(tempArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">            tempArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tempArr;</span><br><span class="line">&#125;</span><br><span class="line">var a = [1, 2, 3, 3, 5, 7, 2, 6, 8];</span><br><span class="line">console.log(mvRepeat(a));</span><br></pre></td></tr></table></figure></p></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">思路2：如果原数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的</span><br><span class="line">(本思路关键点在于：indexOf()方法只返回该元素第一次出现的索引值)</span><br><span class="line">function mvRepeat(arr)&#123;</span><br><span class="line">    var tempArr = [];</span><br><span class="line">    for(var i=0, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">        if(arr.indexOf(arr[i]) == i)&#123;</span><br><span class="line">            tempArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tempArr;</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3,3,4,5,5,6,3,7];</span><br><span class="line">console.log(mvRepeat(a));</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">思路3：先将原数组排序，在与新数组最后一个元素进行比较，如果不同则存入新数组。</span><br><span class="line">(本思路关键点在于：</span><br><span class="line">①新数组初始化时存入原数组第一个元素</span><br><span class="line">②原数组排序</span><br><span class="line">③原数组每个元素是否等于新数组最后一个（length-1号）元素)</span><br><span class="line">function mvRepeat(arr)&#123;</span><br><span class="line">    var tempArr = [arr[0]];</span><br><span class="line">    arr.sort(function(a,b)&#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    for(var i=1, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">        if(tempArr[tempArr.length - 1] !== arr[i])&#123;</span><br><span class="line">            tempArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tempArr;</span><br><span class="line">&#125;</span><br><span class="line">var a = [1, 2, 3, 3, 5, 7, 2, 6, 8];</span><br><span class="line">console.log(mvRepeat(a));</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路4：利用对象属性存在的特性，如果没有该属性则存入新数组。</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路5（最常用）：使用es6 set</span><br><span class="line">let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];</span><br><span class="line">console.log([...new Set(arr)]);         //(7) [1, 2, 3, 5, 7, 6, 8]</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>获取url中的参数(要点：1.location.search2.判断是否为空3.截取、按照'&amp;'符号分数组4.截取每个元素，判断'='前为传入值，则返回数组第二个元素)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getParm(val)&#123;</span><br><span class="line">    var url = window.location.search;</span><br><span class="line">    if(url.indexOf(&apos;?&apos;) !== -1)&#123;</span><br><span class="line">        var arr = url.substr(1).split(&quot;&amp;&quot;);</span><br><span class="line">        var temp = [];</span><br><span class="line">        for(var i = 0, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">            var res = arr[i].split(&quot;=&quot;);</span><br><span class="line">            if(res[0] == val)&#123;</span><br><span class="line">                return res[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getParm(&quot;ie&quot;);</span><br></pre></td></tr></table></figure></p></li><li><p>点击li弹出对应的索引值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.getElementById(&quot;ul&quot;).childNodes;</span><br><span class="line">var len = (lis.length-1)/2;</span><br><span class="line">for (var i = 0; i &lt; len; i++)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        lis[i*2+1].addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>闭包的例子(每次调用函数都加一)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var conAdd = (function()</span><br><span class="line">&#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return i ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(conAdd());</span><br><span class="line">console.log(conAdd());</span><br></pre></td></tr></table></figure></p></li><li><p>事件监听与事件委托<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p>求最大连续递增串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 字符串转数组：str.split(&quot;&quot;);</span><br><span class="line">2. 从第一个开始遍历数组，两个条件(是数字，下一个元素大于该元素1)</span><br><span class="line">3. push进temp[]数组</span><br><span class="line">4. temp[]数组转为字符串存入a[i]数组第i个位置</span><br><span class="line">5. 最后比较长度，取出最大的元素</span><br></pre></td></tr></table></figure></p></li><li><p>字符串转数组与数组转字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.split(&apos;spt&apos;);</span><br><span class="line"></span><br><span class="line">2.jion(&quot;&quot;);</span><br></pre></td></tr></table></figure></p></li><li><p>绑定事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通用事件绑定函数</span><br><span class="line">//封装通用绑定事件函数</span><br><span class="line">// 参数为事件三要素：元素、事件类型、触发函数</span><br><span class="line">function bindEvent(elem, type, fn)&#123;</span><br><span class="line">    elem.addEventListener(type, fn);</span><br><span class="line">&#125;</span><br><span class="line">var link1 = document.getElementById(&apos;link1&apos;);</span><br><span class="line">//使用通用函数</span><br><span class="line">bindEvent(link1, &apos;click&apos;, function(e)&#123;</span><br><span class="line">    //阻止默认行为，在a标签就是阻止跳转页面</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    //要执行的事件</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></li><li><p>圣杯布局与双飞翼布局两者区别：</p></li><li><p>圣杯布局<img src="/img/shengbei.png" alt="banner"></p></li><li><p>双飞翼布局<img src="/img/shuangfeiyi.png" alt="banner"></p></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果有父盒子，则父盒子overflow: hidden;</span><br><span class="line">1. 盒子顺序：main、left、right</span><br><span class="line">2. 三个盒子都float: left</span><br><span class="line">3. 先安排左盒子：margin-left: -100%</span><br><span class="line">4. 再安排右边盒子：margin-left：-200px</span><br><span class="line">5. 安排main：padding: 0 200px</span><br><span class="line">6. 解决left和right跟着main走的问题：position: relative; 再设置left值</span><br><span class="line">完成圣杯布局</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何让它们呈现出一行三列的效果呢？</span><br><span class="line">那就要让左边的盒子要到中间盒子的最左边，右边的盒子到中间盒子的最右边。</span><br><span class="line">换个想法，如果中间盒子不是100%的宽度，那么按照文档流，左边的盒子一定会在中间盒子的后面显示，接着显示右边的盒子。</span><br><span class="line">但是现在中间盒子是满屏了的，所以左右两个盒子被挤到下一行显示。我们要做到的是让左右两个盒子都上去。</span><br><span class="line">此时，CSS的负边距(negative margin)该上阵了。</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何解决left和right跟着main走的问题？</span><br><span class="line">通过对left和right设置position: relative，</span><br><span class="line">改变left值：left: -200px, right: -200px</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 前段面试常考的手撕代码题&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试总结</title>
    <link href="http://yoursite.com/2018/09/03/2018/09/writtenExam/"/>
    <id>http://yoursite.com/2018/09/03/2018/09/writtenExam/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2018-11-02T06:37:04.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 转载一些前人总结的前端笔试面试常见题型，包括ES、Ajax、前端安全等</p><p><a id="more"></a></p><h4>1. JavaScript方面</h4><h3>1.1 变量类型和计算</h3><ol><li><p>值类型和引用类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">var b = a;</span><br><span class="line">a = 200;</span><br><span class="line">则b = ?//100</span><br><span class="line"></span><br><span class="line">var a = &#123;age: 20&#125;;</span><br><span class="line">var b = a;</span><br><span class="line">b.age = 21;</span><br><span class="line">则a.age = ? //21</span><br></pre></td></tr></table></figure></p></li><li><p>typeof</p><p>只能用于区分值类型字符串（string）、数值（number）、布尔值（boolean）、undefined、空指针(null)不能区分出引用类型对象（Object）、数组（Array）、函数（Function）</p></li></ol><ol start="3"><li>类型转换(包括字符串拼接、==运算符、if、逻辑运算)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var a = 100 + &apos;10&apos;;  //&apos;10010&apos;</span><br><span class="line"></span><br><span class="line">100 == &apos;100&apos;;        //true, 100转换为字符串</span><br><span class="line">0 == &apos;&apos;;             //true, 0和&apos;&apos;都会转换为false</span><br><span class="line">null == undefined;   //true, 都会转换为false</span><br><span class="line"></span><br><span class="line">var a = true;</span><br><span class="line">if(a)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">var b = 100;</span><br><span class="line">if(b)&#123;</span><br><span class="line">    //...       b被强制转换为true</span><br><span class="line">&#125;</span><br><span class="line">var c = &apos;&apos;;</span><br><span class="line">if(c)&#123;</span><br><span class="line">    //...       c被强制转换为false</span><br><span class="line">&#125;</span><br><span class="line">//如果不想采用强制转换, 则在b中可以使用 if(!!b)两个感叹号就可转换为布尔类型</span><br><span class="line">//0、NaN、&apos;&apos;、null、undefined、false在if中都是false</span><br><span class="line"></span><br><span class="line">显式转换:</span><br><span class="line">转换为数值类型      ：  Number(mix)、parseInt(string,radix)、parseFloat(string)</span><br><span class="line">转换为字符串类型    ：  toString(radix)、String(mix)</span><br><span class="line">转换为布尔类型      ：  Boolean(mix)</span><br><span class="line"></span><br><span class="line">隐式转换:</span><br><span class="line">检测是否为非数值    :   isNaN(mix)</span><br><span class="line">操作符             :   ++、--、+、&amp;&amp;、||...</span><br><span class="line"></span><br><span class="line">a===a为false，则说明a是：NaN</span><br></pre></td></tr></table></figure></li></ol><h3>1.2 原型和原型链</h3><ol><li><p>构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大写字母开头</span><br><span class="line">var a = &#123;&#125; 的构造函数是 Object()</span><br><span class="line">var b = [] 的构造函数是 Array()</span><br><span class="line">function Foo()&#123;&#125; 的构造函数是 Function()</span><br></pre></td></tr></table></figure></p></li><li><p>原型规则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">研究引用类型(对象、数组、函数)：</span><br><span class="line">(1)所有的引用类型可以自由扩展属性</span><br><span class="line"></span><br><span class="line">(2)__proto__: 隐式原型</span><br><span class="line">   prototype: 显式原型</span><br><span class="line"></span><br><span class="line">(3)引用类型的隐式原型 === 该构造函数的显式原型</span><br><span class="line"></span><br><span class="line">(4)当试图得到对象某个属性时, 如果没有这个属性, 则会去它的__proto__中寻找</span><br></pre></td></tr></table></figure></p></li><li><p>原型链<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当试图得到对象某个属性时, 如果没有这个属性, 则会去它的__proto__中寻找,</span><br><span class="line">即等于在它的构造函数的显示原型去寻找, </span><br><span class="line">如果没有, 构造函数的显示原型(Foo.prototype)可以看作一个对象, 故可以继续找对象的隐式原型</span><br><span class="line">这种寻找方式就叫做原型链(即f.__proto__.__proto__)</span><br></pre></td></tr></table></figure></p></li><li><p>intanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f intanceof prototype 判断逻辑是：</span><br><span class="line">f.__proto__ 是否等于(===) Foo.prototype</span><br></pre></td></tr></table></figure></p></li></ol><h3>1.3 作用域和闭包</h3><ol><li><p>执行上下文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范围：一段&lt;script&gt;或者一个函数</span><br><span class="line">全局：将 &quot;变量定义&quot;、 &quot;函数声明&quot; 拿出来, 变量undefined占位</span><br><span class="line">函数：将变量定义、函数声明、this、arguments拿出来</span><br></pre></td></tr></table></figure></p></li><li><p>this<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">this要在执行时才能确认值, 定义时无法确认</span><br><span class="line">(1) 作为构造函数执行</span><br><span class="line">this.name = name; this.age = age;</span><br><span class="line"></span><br><span class="line">(2) 作为对象属性执行</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name : &apos;phil&apos;,</span><br><span class="line">    print: function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.print();   // this = obj</span><br><span class="line"></span><br><span class="line">(3) 作为普通对象执行</span><br><span class="line">window;</span><br><span class="line">(4) call apply bind</span><br><span class="line">function fn(name)&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(&#123;x:10&#125;, &apos;zhangsan&apos;);   // this = &#123;x:10&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>作用域与作用域链<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局与函数</span><br><span class="line">作用域链就是对函数内的自由变量向外父作用域寻找定义</span><br></pre></td></tr></table></figure></p></li><li><p>闭包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">闭包包含以下要点：</span><br><span class="line">（声明 -&gt; 独立作用域 -&gt; 相互访问 -&gt; 作用域链）</span><br><span class="line">1.函数声明的时候，会生成一个独立的作用域</span><br><span class="line">2.同一作用域的对象可以互相访问</span><br><span class="line">3.作用域呈层级包含状态，形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；另外子作用域会使用最近的父作用域的对象</span><br><span class="line"></span><br><span class="line">闭包的使用场景：</span><br><span class="line">(1)函数作为返回值return function()&#123;&#125;</span><br><span class="line">(2)函数作为参数传递function(a, function()&#123;&#125;)</span><br><span class="line"></span><br><span class="line">闭包的优缺点：</span><br><span class="line">优点： </span><br><span class="line">    1.保护函数内的变量安全,加强了封装性 </span><br><span class="line">    2.在内存中维持一个变量</span><br><span class="line">缺点：</span><br><span class="line">    内存浪费问题</span><br><span class="line"></span><br><span class="line">闭包实例：</span><br><span class="line">计时器</span><br><span class="line"></span><br><span class="line">如何理解计时器：</span><br><span class="line">由于js是单线程的，所以在执行for循环的时候</span><br><span class="line">定时器setTimeout被安排到任务队列中排队等待执行，</span><br><span class="line">而在等待过程中for循环就已经在执行，</span><br><span class="line">等到setTimeout可以执行的时候，for循环已经结束，</span><br><span class="line">i的值也已经编程5，所以打印出来五个5</span><br><span class="line"></span><br><span class="line">如何修改为正确的计时器：</span><br><span class="line">将setTimeout放入立即执行函数中，</span><br><span class="line">将for循环中的循环值i作为参数传递，</span><br><span class="line">100毫秒后同时打印出1 2 3 4 5</span><br></pre></td></tr></table></figure></p></li><li><p>“（）”在javascript中的用法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当有2个（）的时候，如果前面的（）满足表达式规则的时候，</span><br><span class="line">第一个（）会被当成函数来执行，那么第二个（）就是该函数的参数。</span><br></pre></td></tr></table></figure></p></li></ol><h3>1.4 异步与单线程</h3><ol><li>同步和异步<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">是否阻塞后面程序的进行</span><br><span class="line">异步不会阻塞, 同步会阻塞</span><br><span class="line"></span><br><span class="line">console.log(100);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(200);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(300);</span><br><span class="line"></span><br><span class="line">console.log(100);</span><br><span class="line">alter(200);</span><br><span class="line">console.log(300);</span><br></pre></td></tr></table></figure></li></ol><h3>1.5 API</h3><ol><li><p>数组的API<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">forEach:</span><br><span class="line">var arr = [1,2,3];</span><br><span class="line">arr.forEach(function(item, index)&#123;</span><br><span class="line">    //遍历数组</span><br><span class="line">    console.log(index, item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">every:</span><br><span class="line">var arr = [1,2,3];</span><br><span class="line">var result = arr.every(function(item, index)&#123;</span><br><span class="line">    //判断数组所有元素都满足一个条件</span><br><span class="line">    if(item &lt; 4)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">some:</span><br><span class="line">var arr = [1,2,3];</span><br><span class="line">var result = arr.some(function(item, index)&#123;</span><br><span class="line">    //判断数组所有元素, 只要有满足一个条件</span><br><span class="line">    if(item &lt; 2)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">sort:</span><br><span class="line">var arr = [1,4,2,3,5];</span><br><span class="line">var arr2 = arr.sort(function(a, b)&#123;</span><br><span class="line">    //从小到大排序</span><br><span class="line">    return a - b;</span><br><span class="line"></span><br><span class="line">    //从大到小排序</span><br><span class="line">    //return b - a;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr2);</span><br><span class="line"></span><br><span class="line">map:</span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line">var arr2 = arr.map(function(item, index)&#123;</span><br><span class="line">    //将元素重新组装, 并返回</span><br><span class="line">    return &apos;&lt;b&gt;&apos;+ item +&apos;&lt;/b&gt;&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr2);</span><br><span class="line">//&#123;&quot;&lt;b&gt;1&lt;/b&gt;&quot;, ..., &quot;&lt;b&gt;4&lt;/b&gt;&quot;&#125;</span><br><span class="line"></span><br><span class="line">filter:</span><br><span class="line">var arr = [1,2,3,4];</span><br><span class="line">var arr2 = arr.filter(function(item, index)&#123;</span><br><span class="line">    //通过某一个条件过滤数组</span><br><span class="line">    if(item &gt;= 2)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr2);</span><br><span class="line">//2,3,4</span><br></pre></td></tr></table></figure></p></li><li><p>字符串的API<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">substr()和substring()的区别？</span><br><span class="line">区别仅仅在于第二个参数</span><br><span class="line"></span><br><span class="line">substr()第二个参数代表截取个数</span><br><span class="line">substring()第二个参数代表截取位置索引值（但是不包括该值）</span><br></pre></td></tr></table></figure></p></li></ol><h3>1.6 DOM和BOM</h3><ol><li><p>DOM节点操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">获取DOM节点</span><br><span class="line">get..、 get...、 querySelectorAll</span><br><span class="line"></span><br><span class="line">prototype(属性)比较常见的一种设置对象属性的方法</span><br><span class="line">p.style.width</span><br><span class="line"></span><br><span class="line">Attribute(属性)利用set和get设置标签属性的方法</span><br><span class="line">p.getAttribute(&apos;style&apos;);</span><br><span class="line">p.setAttribute(&apos;style&apos;, &apos;font-size: 20px;&apos;);</span><br><span class="line"></span><br><span class="line">两者区别：一个是操作js属性，一个是操作html属性</span><br></pre></td></tr></table></figure></p></li><li><p>DOM结构操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">新增节点</span><br><span class="line">creatElement和appendChild</span><br><span class="line"></span><br><span class="line">获取父节点</span><br><span class="line">parentElement</span><br><span class="line"></span><br><span class="line">获取子节点</span><br><span class="line">childNodes</span><br><span class="line"></span><br><span class="line">删除节点</span><br><span class="line">removeChild</span><br></pre></td></tr></table></figure></p></li><li><p>BOM<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">navigator：</span><br><span class="line">navigator.userAgent</span><br><span class="line"></span><br><span class="line">screen</span><br><span class="line">screen.width</span><br><span class="line">screen.height</span><br><span class="line"></span><br><span class="line">location</span><br><span class="line">location.href</span><br><span class="line">location.host</span><br><span class="line">location.protocal</span><br><span class="line">location.pathname</span><br><span class="line">location.search</span><br><span class="line">location.hash</span><br><span class="line"></span><br><span class="line">history</span><br><span class="line">history.back()</span><br><span class="line">history.forward()</span><br></pre></td></tr></table></figure></p></li></ol><h3>1.7 事件</h3><ol><li><p>事件冒泡</p><p>DOM树形结构事件冒泡阻止冒泡</p></li></ol><ol start="2"><li><p>事件代理</p><p>代码简洁减少浏览器内存占用</p></li></ol><h4>2. Html</h4><ol><li>w3c标准盒子模型与IE盒子模型的区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">盒子模型=margin+border+padding+content</span><br><span class="line">W3C: width = content</span><br><span class="line">IE： width = content + padding + border</span><br></pre></td></tr></table></figure></li></ol><h4>3. Css和Css3</h4><ol><li><p>CSS3新属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(1)边框</span><br><span class="line">border-radius：圆角边框，border-radius:25px;</span><br><span class="line">box-shadow：边框阴影，box-shadow: 10px 10px 5px #888888;</span><br><span class="line">border-image：边框图片，border-image:url(border.png) 30 30 round;</span><br><span class="line"></span><br><span class="line">(2)背景</span><br><span class="line">·background-size：规定背景图片的尺寸，background-size:63px 100px;</span><br><span class="line">·background-origin：规定背景图片的定位区域，背景图片可以放置于 content-box、padding-box 或 border-box 区域。</span><br><span class="line">·background-image:url(bg_flower.gif),url(bg_flower_2.gif)：CSS3 允许您为元素使用多个背景图像。</span><br><span class="line"></span><br><span class="line">(3)文本效果</span><br><span class="line">·text-shadow：向文本应用阴影，可以规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。text-shadow: 5px 5px 5px #FF0000;</span><br><span class="line">·word-wrap：允许文本进行换行。word-wrap:break-word;</span><br><span class="line"></span><br><span class="line">(4)字体</span><br><span class="line">@font-face 规则可以自定义字体</span><br><span class="line">&lt;style&gt; </span><br><span class="line">@font-face&#123;</span><br><span class="line">    font-family: myFirstFont;</span><br><span class="line">    src: url(&apos;Sansation_Light.ttf&apos;),</span><br><span class="line">        url(&apos;Sansation_Light.eot&apos;); /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">    font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">(5)2D转换</span><br><span class="line">·translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 transform: translate(50px,100px);</span><br><span class="line">·rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform: rotate(30deg);</span><br><span class="line">·scale()：元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。transform: scale(2,4);</span><br><span class="line">·skew()：元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。transform: skew(30deg,20deg);</span><br><span class="line">·matrix()： 把所有 2D  转换方法组合在一起，需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class="line"></span><br><span class="line">(6)3D转换</span><br><span class="line">·rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform: rotateX(120deg);</span><br><span class="line">·rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform: rotateY(130deg);</span><br><span class="line"></span><br><span class="line">(7)transition</span><br><span class="line">·transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。</span><br><span class="line">·transition-duration：过渡动画的一个持续时间。</span><br><span class="line">·transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 。</span><br><span class="line">·transition-delay：延迟多久后开始动画。</span><br><span class="line"></span><br><span class="line">(8)animation</span><br><span class="line">使用CSS3 @keyframes 规则。</span><br><span class="line">·animation-name: 定义动画名称</span><br><span class="line">·animation-duration: 指定元素播放动画所持续的时间长</span><br></pre></td></tr></table></figure></p></li><li><p>rem和em？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rem:</span><br><span class="line">以html的font-size为基准</span><br><span class="line">html&#123;</span><br><span class="line">    font-size: 62.5%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">em:</span><br><span class="line">以父元素的font-size为基准</span><br><span class="line">@media only screen and (max-width: 30em)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>隐藏元素的方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">opacity:</span><br><span class="line">元素会触发绑定的事件，例如点击会触发click函数。</span><br><span class="line">.hide &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visibility</span><br><span class="line">元素仍会占用页面空间</span><br><span class="line">元素不会触发绑定的事件</span><br><span class="line">.hide &#123;</span><br><span class="line">   visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display</span><br><span class="line">元素将不会再占用页面空间</span><br><span class="line">display: none;</span><br></pre></td></tr></table></figure></p></li><li><p>inline、block、inline-block的区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">display: inline</span><br><span class="line">元素不会独占一行\\\设置width,height属性无效</span><br><span class="line">常见的行级元素:&lt;a&gt;,&lt;b&gt;,&lt;i&gt;,&lt;em&gt;,&lt;img&gt;,&lt;input&gt;,&lt;span&gt;</span><br><span class="line"></span><br><span class="line">display: block</span><br><span class="line">元素会独占一行\\\可以设置width,height属性</span><br><span class="line">常见的块级元素:&lt;h1&gt;,&lt;li&gt;,&lt;div&gt;,&lt;form&gt;,&lt;p&gt;等</span><br><span class="line"></span><br><span class="line">display: inline-block</span><br><span class="line">既具有block的宽度高度特性\\\又具有inline的同行特性</span><br></pre></td></tr></table></figure></p></li><li><p>一行多个元素排布的实现方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p>清除浮动</p></li></ol><p>给父元素添加class-clearfix<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">代码量较多，原理相对其他几种清除方法稍复杂</span><br></pre></td></tr></table></figure></p><p>浮动元素后添加空元素并clear: both;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cl&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.cl&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">添加多少无意义的空标签，有违结构与表现的分离</span><br></pre></td></tr></table></figure></p><p>给父元素添加 overflow: hidden;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.fa&#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素</span><br></pre></td></tr></table></figure></p><ol start="7"><li>块元素与行元素</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常见的行级元素:&lt;a&gt;,&lt;b&gt;,&lt;i&gt;,&lt;em&gt;,&lt;img&gt;,&lt;input&gt;,&lt;span&gt;</span><br><span class="line">常见的块级元素:&lt;h1&gt;,&lt;li&gt;,&lt;div&gt;,&lt;form&gt;,&lt;p&gt;等</span><br></pre></td></tr></table></figure></p><ol start="8"><li><p>移动端适配方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rem</span><br><span class="line">百分比</span><br><span class="line">flex</span><br></pre></td></tr></table></figure></p></li><li><p>css的box-sizing属性及区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content-box，border和padding不计算入width之内</span><br><span class="line"></span><br><span class="line">border-box，border和padding计算入width之内</span><br></pre></td></tr></table></figure></p></li><li></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style&gt;ID（#content）&gt;class(.content)=伪类(:hover)&gt;标签选择器(div,span)&gt;通配符(*)</span><br></pre></td></tr></table></figure></p><h4>4. ECMAScript6</h4><ol><li><p>let和const：</p><p>let定义变量，const定义常量(比如PI)不能重复定义(避免造成变量命名冲突)块级作用域({只在这里面生效}、for循环里面let i=0)不存在变量提升(指的是先使用再声明)</p></li></ol><ol start="2"><li><p>箭头函数：</p><p>参数 =&gt; 表达式/语句let a = elem =&gt; {do something;}</p><p>继承外层作用域不能用作构造函数(箭头函数没有构造方法)没有prototype属性</p></li></ol><ol start="3"><li><p>模板字符串</p><p>基本用法let str = '&lt;div&gt;123&lt;/div&gt;';</p><p>嵌套变量let num = 123;let str = '&lt;div&gt;${num}&lt;/div&gt;';</p><p>嵌套函数let fn = () =&gt; {//do something}let str = '&lt;div&gt;${fn()}&lt;/div&gt;';</p><p>循环嵌套let nums = [1, 2, 3];let str = ' &lt;ul&gt;${nums.map(num =&gt; '&lt;li&gt;${num&lt;/li&gt;').join(' ')}&lt;/ul&gt;';</p></li></ol><ol start="3"><li>promise 用法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">使用</span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br><span class="line">//等价于：</span><br><span class="line">promise.then(function()&#123;</span><br><span class="line">  //success</span><br><span class="line">&#125;).catch(function()&#123;</span><br><span class="line">  //failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4>5. ajax</h4><ol><li>XMLHttpRequest<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//new一个XMLHttpRequest对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">//发送请求, 请求方法get, 请求地址api, 异步请求false</span><br><span class="line">xht.open(&quot;GET&quot;, &quot;/api&quot;, false);</span><br><span class="line">//一直监听readyState状态码的变化</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    //4表示已经返回, 200表示返回成功</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            //执行事件, responseText是服务端返回的内容</span><br><span class="line">            alter(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readyState:</span><br><span class="line">0 - (未初始化)还没有调用send()方法</span><br><span class="line">1 - (载入) 已调用send()方法, 正在发送请求</span><br><span class="line">2 - (载入完成) send()方法执行完成, 已经收到全部响应内容</span><br><span class="line">3 - (交互) 正在解析响应内容</span><br><span class="line">4 - (完成) 响应内容解析完成, 可以在客户端调用了</span><br></pre></td></tr></table></figure></p><ol start="2"><li>跨域<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同源策略</span><br><span class="line">跨域条件：协议、域名、端口</span><br><span class="line">可以跨域的三个标签：&lt;img src=xxx&gt;&lt;link href=xxx&gt;&lt;script src=xxx&gt;</span><br></pre></td></tr></table></figure></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1. jsonp</span><br><span class="line">JSONP的方式其实是在末尾加入script标签，src指向后端地址/后台文件，？后的参数callback等于前端要处理数据的函数名。后端文件需要通过GET方法得到前端处理数据的函数名，并且将数据计入数组，通过callback回调函数输出返回数据。</span><br><span class="line">【JSONP的优缺点】</span><br><span class="line">优点：兼容性好（兼容低版本IE）</span><br><span class="line">缺点：1.JSONP只支持GET请求； 2.XMLHttpRequest相对于JSONP有着更好的错误处理机制</span><br><span class="line"></span><br><span class="line">2. CORS</span><br><span class="line">CORS 是W3C 推荐的一种新的官方方案，</span><br><span class="line">能使服务器支持 XMLHttpRequest 的跨域请求。</span><br><span class="line">只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。</span><br><span class="line">简单请求:在http请求中origin字段标明跨域地址，</span><br><span class="line">在http响应加入Access-Control-Allow-Origin: *（访问控制允许同源），</span><br><span class="line">表明该资源可以被任意外域访问。</span><br><span class="line">通俗讲就是浏览器在发现跨域请求的时候会附加一些头信息和服务器进行沟通，</span><br><span class="line">来确定跨域请求通不通过。</span><br><span class="line"></span><br><span class="line">3.window.postMessage(message,targetOrigin)</span><br><span class="line">window.postMessage(message,targetOrigin) 方法是html5新引进的特性，</span><br><span class="line">可以使用它来向其它的window对象发送消息，</span><br><span class="line">无论这个window对象是属于同源或不同源。</span><br><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br><span class="line">message 属性是要发送的消息，类型为 String、Object 。</span><br><span class="line">targetOrigin:属性来指定哪些窗口能接收到消息事件，</span><br><span class="line">其值可以是字符串&quot;*&quot;（表示无限制）或者一个URI。</span><br><span class="line"></span><br><span class="line">4.location.hash + iframe</span><br><span class="line">location.hash + iframe 跨域通信的实现是这样的：</span><br><span class="line"></span><br><span class="line">不同域的 a 页面与 b 页面进行通信，在 a 页面中通过 iframe 嵌入 b 页面，并给 iframe 的 src 添加一个 hash 值。</span><br><span class="line">b 页面接收到了 hash 值后，确定 a 页面在尝试着与自己通信，然后通过修改 parent.location.hash 的值，将要通信的数据传递给 a 页面的 hash 值。</span><br><span class="line">但由于在 IE 和 Chrmoe 下不允许子页面直接修改父页面的 hash 值，所以需要一个代理页面，通过与 a 页面同域的 c 页面来传递数据。</span><br><span class="line">同样的在 b 页面中通过 iframe 嵌入 c 页面，将要传递的数据通过 iframe 的 src 链接的 hash 值传递给 c 页面，由于 a 页面与 c 页面同域，c 页面可以直接修改 a 页面的 hash 值或者调用 a 页面中的全局函数。</span><br><span class="line">总结一下就是a页面嵌入iframe指向b，b页面嵌入iframe指向c，c页面修改a的hash值</span><br></pre></td></tr></table></figure></p><h4>6. 性能优化、前端安全与网络知识</h4><ol><li><p>性能优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">减少页面体积：</span><br><span class="line">(1)静态资源的压缩合并(webpack的commonJS和AMD)</span><br><span class="line">(2)静态资源缓存(本地缓存)&lt;link rel=&quot;dns-perfetch&quot; href=&quot;www.xizi.top&quot;&gt;</span><br><span class="line">(3)使用CDN让资源加载更快</span><br><span class="line">(4)使用SSR后端渲染, 数据直接输出到HTML中</span><br><span class="line"></span><br><span class="line">优化页面渲染：</span><br><span class="line">(1)CSS放在前面, JS放在后面</span><br><span class="line">(2)懒加载</span><br><span class="line">(3)减少DOM查询, 对DOM查询做缓存</span><br><span class="line">(4)减少DOM操作, 多个操作尽量合并在一起执行(DOM操作是十分昂贵的)</span><br><span class="line">(5)事件节流</span><br><span class="line">(6)尽早执行操作</span><br></pre></td></tr></table></figure></p></li><li><p>安全性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XSS(跨站请求攻击)</span><br><span class="line">在输入内容中加入&lt;script&gt;脚本</span><br><span class="line"></span><br><span class="line">XSRF(跨站请求伪造)</span><br><span class="line">在邮件的&lt;img src=&quot;付费链接&quot;&gt;隐藏付费链接</span><br></pre></td></tr></table></figure></p></li><li><p>浏览器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http和https的区别?</span><br><span class="line">http主要有三点：</span><br><span class="line">1. 通信采用明文会被窃听</span><br><span class="line">2. 无法确认通信方的身份</span><br><span class="line">3. 无法确认报文内容的完整性</span><br><span class="line">https:</span><br><span class="line">https = http + 加密 + 认证 + 完整性保护</span><br><span class="line">      = http + SSL(安全套接层)</span><br></pre></td></tr></table></figure></p></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP连接为什么要三次握手？</span><br><span class="line">防止第一次连接失效</span><br><span class="line"></span><br><span class="line">三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”</span><br><span class="line">一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。</span><br><span class="line">本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。</span><br><span class="line">此时为了确定此次连接是否失效，A像B发送表示未失效，A不响应表示已经失效</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP为什么四次挥手？</span><br><span class="line">全双工，双发读写都要关闭</span><br><span class="line"></span><br><span class="line">tcp是全双工的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，</span><br><span class="line">但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TCP和UDP区别？</span><br><span class="line">连接与无连接 | 可靠与不可靠 | 实时性 | 点到点与多对多 | 资源要求 </span><br><span class="line"></span><br><span class="line">1.TCP面向连接，即发送数据之前需要建立连接；UDP是无连接的。</span><br><span class="line"></span><br><span class="line">2.TCP提供可靠服务，通过TCP连接的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠的交付</span><br><span class="line"></span><br><span class="line">TCP通过校验和，重传控制，序号标识，滑动窗口，确认应答实现可靠传输。</span><br><span class="line"></span><br><span class="line">3.UDP具有较好的实时性，工作效率比TCP高，适用于高速传输和实时性具有较高的通信或广播通信。</span><br><span class="line"></span><br><span class="line">4.每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的互相通信</span><br><span class="line"></span><br><span class="line">5.TCP对系统资源要求较多，UDP对系统要求较少</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET和POST的区别，何时使用POST？</span><br><span class="line">信息获取和修改资源  | 地址栏和表单  |  数据量限制</span><br><span class="line"></span><br><span class="line">GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</span><br><span class="line">POST：一般用于修改服务器上的资源，对所发送的信息没有限制</span><br><span class="line"></span><br><span class="line">GET方式需要使用 Request.QueryString 来取得变量的值</span><br><span class="line">POST方式通过 Request.Form 来获取变量的值</span><br><span class="line">也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。</span><br><span class="line"></span><br><span class="line">在以下情况中，请使用 POST 请求：</span><br><span class="line">1. 无法使用缓存文件（更新服务器上的文件或数据库）</span><br><span class="line">2. 向服务器发送大量数据（POST 没有数据量限制）</span><br><span class="line">3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP协议默认的端口号__80__</span><br><span class="line">HTTPS协议的端口号__443__</span><br></pre></td></tr></table></figure></p><h4>7.开发工具</h4><p>webpack与gulp的区别？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Gulp类似于一个产品流水线，对配置文件gulpfile.js中的task配置路径下所有文件进行相关的操作。</span><br><span class="line"></span><br><span class="line">webpack对于一切文件视为模块，根据配置文件webpack.config.js中的</span><br><span class="line">entry入口文件的依赖文件层层递归并静态分析，运用相对应的规则转换为静态资源。</span><br></pre></td></tr></table></figure></p><p>虚拟DOM的结构？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在APP和DOM之间增加了Virtual DOM</span><br></pre></td></tr></table></figure></p><p>为什么采用Virtual DOM<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页面变更的代价变低</span><br><span class="line">树形结构有关，降低时间复杂度</span><br></pre></td></tr></table></figure></p><p>如何实现？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff算法做比较</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write();</span><br><span class="line">打印在页面</span><br></pre></td></tr></table></figure></p><h4>8. 必备算法</h4><p>点击链接查看: <a href="https://xirenbunong.github.io/2018/02/25/2018/02/algorithm/" target="_blank" rel="noopener">算法概要</a></p><h4>9. 例题解析</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">何时使用==, 何时使用===?</span><br><span class="line">除了以下两种情况，其他时刻都用===</span><br><span class="line">(1)判断对象的属性是否存在</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">if (obj.a == null) &#123;</span><br><span class="line">    // 这里相当于 obj.a === null || obj.a === undefined 的简写形式</span><br><span class="line">    // 这是jquery源码中推荐的写法</span><br><span class="line">&#125;</span><br><span class="line">(2)判断函数的参数是否存在</span><br><span class="line">function fn(a, b) &#123;</span><br><span class="line">    if (b == null) &#123;</span><br><span class="line">        // 这里相当于 b === null || b === undefined 的简写形式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof()输出：</span><br><span class="line">||type||    ||result||</span><br><span class="line"></span><br><span class="line">Undefined   &quot;undefined&quot;</span><br><span class="line">Null        &quot;object&quot;   ***</span><br><span class="line">Boolean     &quot;boolean&quot;</span><br><span class="line">Number      &quot;number&quot;</span><br><span class="line">String      &quot;string&quot;</span><br><span class="line">Symbol      &quot;symbol&quot;    Symbol 生成一个全局唯一的值</span><br><span class="line"></span><br><span class="line">Function    &quot;function&quot;</span><br><span class="line">Object      &quot;object&quot;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js的内置函数有?</span><br><span class="line">Object、Array、Boolean、Number、String、Function、Date、RegExp、Error</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js按照存储方式区分变量类型?</span><br><span class="line">值类型：string、number、boolean、undefined</span><br><span class="line">引用类型：对象、数组、函数</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何理解json?(两个方面：数据格式, 内置对象)</span><br><span class="line">json不是内置函数, 而是内置的对象</span><br><span class="line">json有两个api，分别是stringify和parse</span><br><span class="line">一个是将对象转换为字符串，另一个是将字符串转换为对象</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何准确判断一个变量是数组类型?</span><br><span class="line">数组是引用类型, 所以不能使用typeof, 要使用intanceof</span><br><span class="line">过程arr.__proto__ -- 构造函数的prototype -- Array的prototype</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写一个原型链继承的例子?</span><br><span class="line">个人觉得就是在构造函数外部 写方法, </span><br><span class="line">使用时先在构造函数中寻找, 构造函数没有就在prototype寻找</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">描述new一个对象的过程?</span><br><span class="line">new一个新对象</span><br><span class="line">this指向这个新对象</span><br><span class="line">执行代码, 即对this赋值</span><br><span class="line">返回this</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说一下对变量提升的理解?</span><br><span class="line">执行上下文</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明this几种不同的使用场景?</span><br><span class="line">(1) 作为构造函数执行</span><br><span class="line">(2) 作为对象属性执行</span><br><span class="line">(3) 作为普通对象执行</span><br><span class="line">(4) call apply bind</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何理解作用域?</span><br><span class="line">自由变量</span><br><span class="line">作用域链</span><br><span class="line">闭包的两个场景</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步和异步的区别是什么?</span><br><span class="line">是否阻塞后面程序的进行</span><br><span class="line">异步不会阻塞, 同步会阻塞</span><br><span class="line">异步例如setTimeout</span><br><span class="line">同步例如两个console.log中加入一行alter, 只有点击确认后才会执行第三行的console.log</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前端使用异步的场景有哪些?</span><br><span class="line">都需要等待, 等待的过程中不能阻塞, 所以需要异步</span><br><span class="line">(1)定时任务：setTimeout、setInverval</span><br><span class="line">(2)网络请求：ajax请求、动态&lt;img&gt;加载</span><br><span class="line">(3)事件绑定</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOM是哪种基本的数据结构?</span><br><span class="line">树</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何检测浏览器的类型?</span><br><span class="line">var ua = navigator.userAgent;</span><br><span class="line">var isChrome = ua.indexOf(&apos;Chrome&apos;);</span><br><span class="line">//Chrome打开返回81, 错误返回-1, 根据非-1判断浏览器类型</span><br><span class="line">alert(isChrome);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">拆解url的各部分?</span><br><span class="line">location：</span><br><span class="line">https://www.baidu.com/ss.html?cid=99&amp;a=b#mid=100</span><br><span class="line">location.href</span><br><span class="line">&quot;https://www.baidu.com/ss.html?cid=99&amp;a=b#mid=100&quot;</span><br><span class="line">location.host</span><br><span class="line">&quot;www.baidu.com&quot;</span><br><span class="line">location.protocal</span><br><span class="line">&quot;https:&quot;</span><br><span class="line">location.pathname</span><br><span class="line">&quot;/ss.html&quot;</span><br><span class="line">location.search</span><br><span class="line">&quot;?cid=99&quot;</span><br><span class="line">location.hash</span><br><span class="line">&quot;#mid=100&quot;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编写一个通用的事件监听函数?</span><br><span class="line">&lt;!-- 自定义函数 --&gt;</span><br><span class="line">function bindEvent(elem, type, fn)&#123;</span><br><span class="line">    elem.addEventListener(type, fn);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 使用函数 --&gt;</span><br><span class="line">bindEvent(a, &apos;click&apos;, function(e)&#123;</span><br><span class="line">    &lt;!-- 阻止默认行为 --&gt;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    &lt;!-- 事件 --&gt;</span><br><span class="line">    console.log(&apos;111&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">描述事件冒泡流程?</span><br><span class="line">DOM树形结构</span><br><span class="line">事件冒泡</span><br><span class="line">阻止冒泡</span><br><span class="line"></span><br><span class="line">事件冒泡示例：</span><br><span class="line">&lt;div class=&quot;L&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;M1&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;p1&quot;&gt;确认&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;M2&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var p1 = document.getElementById(&apos;p1&apos;);</span><br><span class="line">var L = document.getElementByClassName(&apos;L&apos;);</span><br><span class="line">bindEvent(p1, &apos;click&apos;, function(e)&#123;</span><br><span class="line">    &lt;!-- 阻止冒泡，否则也会弹出取消 --&gt;</span><br><span class="line">    e.stopPropatation();</span><br><span class="line">    alert(&apos;确认&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;!-- 点击确认弹出确认，点击取消弹出取消 --&gt;</span><br><span class="line">&lt;!-- p2-p6都没有单独绑定事件，所以冒泡到class=L执行 --&gt;</span><br><span class="line">bindEvent(L, &apos;click&apos;, function(e)&#123;</span><br><span class="line">    alert(&apos;取消&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建10个a标签，点击时弹出对应的序号？</span><br><span class="line">var i;</span><br><span class="line">for (i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    (function(i)</span><br><span class="line">        var a = document.creatElement(&apos;a&apos;);</span><br><span class="line">        a.innerHTML = i + &apos;&lt;br&gt;&apos;;</span><br><span class="line">        a.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">            e.preventDefualt();</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;)</span><br><span class="line">        document.body.appendChild(a);</span><br><span class="line">    )(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于无限下拉加载图片的页面, 绑定事件?</span><br><span class="line">使用代理</span><br><span class="line">知道代理的两个优点(代码简洁、减少浏览器内存占用)</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">手动编写一个ajax</span><br><span class="line">//new一个XMLHttpRequest对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">//发送请求, 请求方法get, 请求地址api, 异步请求false</span><br><span class="line">xht.open(&quot;GET&quot;, &quot;/api&quot;, false);</span><br><span class="line">//一直监听readyState状态码的变化</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    //4表示已经返回, 200表示返回成功</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            //执行事件, responseText是服务端返回的内容</span><br><span class="line">            alter(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将信息发送到服务器</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">请描述一下cookie, sessionStorage, localStorage的区别?</span><br><span class="line">cookie:</span><br><span class="line">存储量太小, 只有4KB</span><br><span class="line">所有http请求都带着, 影响获取资源效率</span><br><span class="line">API简单, 需要封装才能用</span><br><span class="line"></span><br><span class="line">sessionStorage, localStorage：</span><br><span class="line">存储量5M</span><br><span class="line">不是每次在请求</span><br><span class="line">API易用</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从输入url到得到html的详细过程?</span><br><span class="line"></span><br><span class="line">前端层面：</span><br><span class="line">根据HTML结构生成DOM Tree</span><br><span class="line">根据CSS生成CSSOM</span><br><span class="line">将DOM和CSSOM整合形成RenderTree</span><br><span class="line">根据RenderTree开始渲染和展示</span><br><span class="line">遇到&lt;script&gt;时, 会执行并阻塞渲染</span><br><span class="line"></span><br><span class="line">网络层面：</span><br><span class="line">DNS解析</span><br><span class="line">TCP连接 三次握手</span><br><span class="line">发送HTTP请求（请求头+参数）</span><br><span class="line">服务器处理请求并返回HTTP报文（status状态码+响应头+响应内容body）</span><br><span class="line">浏览器解析渲染页面</span><br><span class="line">连接结束</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onload和DOMContentLoaded的区别?</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery获得内容?</span><br><span class="line">&lt;p id=&quot;test&quot;&gt;这是段落中的&lt;b&gt;粗体&lt;/b&gt;文本。&lt;/p&gt;</span><br><span class="line">$(&quot;#test&quot;).text()       //&quot;这是段落中的粗体文本。&quot;</span><br><span class="line">$(&quot;#test&quot;).html()       //&quot;这是段落中的&lt;b&gt;粗体&lt;/b&gt;文本。&quot;</span><br><span class="line">text() - 设置或返回所选元素的文本内容</span><br><span class="line">html() - 设置或返回所选元素的内容（包括 HTML 标记）</span><br><span class="line">val() - 设置或返回表单字段的值</span><br><span class="line">attr() - 设置或返回属性</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gulp类似于一个产品流水线，对配置文件gulpfile.js中的task配置路径下所有文件进行相关的操作。</span><br><span class="line"></span><br><span class="line">webpack对于一切文件视为模块，根据配置文件webpack.config.js中的entry入口文件的依赖文件层层递归并静态分析，运用相对应的规则转换为静态资源。</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组去重?</span><br><span class="line">思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中</span><br><span class="line">思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</span><br><span class="line">思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。</span><br><span class="line">思路4（最常用）：使用es6 set</span><br><span class="line">let arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];</span><br><span class="line">console.log([...new Set(arr)]);         //(7) [1, 2, 3, 5, 7, 6, 8]</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正则实现trim()功能</span><br><span class="line">function myTrim(str) &#123;</span><br><span class="line">  let reg = /^\s+|\s+$/g;</span><br><span class="line">  return str.replace(reg, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(myTrim(&apos;    asdf    &apos;));</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JS 继承的例子?</span><br><span class="line">// 动物</span><br><span class="line">function Animal() &#123;</span><br><span class="line">    this.eat = function () &#123;</span><br><span class="line">        console.log(&apos;animal eat&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 狗</span><br><span class="line">function Dog() &#123;</span><br><span class="line">    this.bark = function () &#123;</span><br><span class="line">        console.log(&apos;dog bark&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = new Animal()     ***</span><br><span class="line">// 哈士奇</span><br><span class="line">var 二狗子 = new Dog()</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写一个 事件委托和事件代理？</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for 中setTimeout</span><br><span class="line">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    (function(j)&#123;</span><br><span class="line">        setTimeout(function timer()&#123;</span><br><span class="line">            console.log(j);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new操作符做了什么？ </span><br><span class="line">var obj = new Base();</span><br><span class="line"></span><br><span class="line">（1）创建了一个空对象</span><br><span class="line">var obj  = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">（2）设置原型链</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"></span><br><span class="line">（3）将Base函数对象的this指针替换成obj，然后再调用Base函数</span><br><span class="line">Base.call(obj);</span><br><span class="line"></span><br><span class="line">（4）判断返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。</span><br><span class="line">if (typeof(result) == &quot;object&quot;)&#123;  </span><br><span class="line">    fnObj = result;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">    fnObj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">阻止冒泡事件和默认事件 </span><br><span class="line">e.stopPropagation();</span><br><span class="line">e.preventDefault();</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">写出异步加载方案:</span><br><span class="line">$(document).ready</span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">  alert(&quot;加载完成！&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">标签的async=”async”属性 </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;demo_async.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">defer：</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot;&gt; </span><br><span class="line">    alert(document.getElementById(&quot;p1&quot;).firstChild.nodeValue); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/software.jpg" alt="banner"><img src="/img/getANDpost.jpg.png" alt="banner"></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var b = 3;</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">b = 5;</span><br><span class="line">console.log(b);   //5</span><br><span class="line">var b = 2;         </span><br><span class="line">console.log(b);   //2(同名覆盖)</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(b);   //3(闭包内部变量保持)</span><br></pre></td></tr></table></figure></p><h4>10. 数据库</h4><p>说一说三个范式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.一范式就是属性不可分割。属性是什么? 就是表中的字段</span><br><span class="line">不可分割的意思就是最小单位，不能分为更小的单位了</span><br><span class="line"></span><br><span class="line">2.二范式就是要有主键，要求其他字段都依赖于主键。</span><br><span class="line">为什么要有主键? 没有主键就没有唯一性，没有唯一性就不能定位到这一行</span><br><span class="line">其他字段为什么要依赖于主键? 因为不依赖与主键就不能找到他们</span><br><span class="line"></span><br><span class="line">3.三范式就是要消除传递依赖，方便理解，可以看做是“消除冗余”</span><br><span class="line">消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line"></span><br><span class="line">1NF：字段是最小的的单元不可再分 </span><br><span class="line">2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键 (一般我们都会做到)</span><br><span class="line">3NF：满足2NF,非主键外的所有字段必须互不依赖</span><br><span class="line">4NF：满足3NF,消除表中的多值依赖</span><br></pre></td></tr></table></figure></p><p>索引是什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引就是加快检索表中数据的方法</span><br><span class="line">几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</span><br></pre></td></tr></table></figure></p><p>什么是事务？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓的事务，它是一个操作序列，</span><br><span class="line">这些操作要么都执行，要么都不执行，</span><br><span class="line">它是一个不可分割的工作单位。</span><br></pre></td></tr></table></figure></p><p>点击链接查看: <a href="https://xirenbunong.github.io/2018/02/04/2018/02/WEcode/" target="_blank" rel="noopener">笔试面试手撕代码</a></p><h4>11. 非技术</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">面试结束后，面试官问还有什么想要了解的？</span><br><span class="line">技术面试官：</span><br><span class="line">1. 公司项目中运用到的技术；</span><br><span class="line">2. 如果自己有幸被贵公司选中，需要掌握什么技术，需要掌握到什么程度，大概需要在什么时间范围内；</span><br><span class="line">3. 公司业务流程和团队建设等等；</span><br><span class="line"></span><br><span class="line">HR：</span><br><span class="line">1. 公司福利；</span><br><span class="line">2. 假期和加班；</span><br><span class="line">3. 薪资</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 转载一些前人总结的前端笔试面试常见题型，包括ES、Ajax、前端安全等&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>react入门基础</title>
    <link href="http://yoursite.com/2018/08/17/2018/08/react/"/>
    <id>http://yoursite.com/2018/08/17/2018/08/react/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2018-10-31T01:46:24.567Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> React 是一个用于构建用户界面的 javascript 库。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p><p><a id="more"></a></p><h5>1. 通过CDN使用react</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- react.min.js - React 的核心库</span><br><span class="line">    react-dom.min.js - 提供与 DOM 相关的功能</span><br><span class="line">    babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码 --&gt;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">&lt;!-- text/babel注意类型是babel --&gt;</span><br><span class="line">function HelloMessage(props) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello World!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const element = &lt;HelloMessage /&gt;;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&apos;example&apos;)</span><br><span class="line">);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>1.函数<br>2.变量接收函数<br>3.放入变量，并确定插入位置</p><h5>2. 通过命令行create-react-app</h5><pre><code>//国内使用 npm 速度很慢，你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm  $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ npm config set registry https://registry.npm.taobao.org//全局安装create-react-app$ cnpm install -g create-react-app//创建my-app空项目 $ create-react-app my-app//进入项目目录$ cd my-app///启动项目$ npm start</code></pre><h5>3. 在已有项目项目中添加</h5><p>A. git</p><ol><li>vim .gitconfig</li><li>密钥</li><li>在github中创建项目，在项目中添加密钥</li><li>git clone项目到本地项目目录</li><li>vim .gitignore(node_modules、dist、*.log)</li></ol><p>B.nodeJs、yarn</p><ol><li>安装nodeJs@6.12.3</li><li>安装yarn@1.3.2 (npm install yarn -g)</li></ol><p>C.项目初始化</p><ol><li>yarn init(自动生成package.json)</li></ol><p>D. webpack</p><ol><li>安装webpack(yarn add webpack@3.10.0 --dev)</li><li>新建webpack.config.js文件(文件内容参照官网)</li><li>新建src文件夹及其下app.js</li><li>修改entry的路径为./src/app.js, filename为app.js</li></ol><p>F. 对html的处理(安装配置Html单独打包插件)</p><ol><li>安装(yarn add html-webpack-plugin@2.30.1 --dev)</li><li>配置(const HtmlWebpackPlugin的require引入，然后在plugin中添加new HtmlWebpackPlugin(),自己在src下写一个Html模板, 在()中插入{template: './src/index.html'})</li></ol><p>G. 对脚本的处理(babel、react)</p><ol><li>处理ES6语法(yarn add babel-core@6.26.0 babel-preset-env@1.6.1 babel-loader@7.1.2 --dev)</li><li>处理react语法(yarn add babel-preset-react@6.24.1 --dev)</li><li>安装react(yarn add react@16.2.0 react-dom@16.2.0)</li><li>修改配置 //添加modules: {rules: [{test: /.jsx$/,esclude: /(node_modules)/,use: {loader: 'babel-loader',options: {presets: ['env', 'react']}}}]}</li></ol><p>H. 对CSS的处理(style-loader、css-loader)</p><ol><li></li></ol><p>I. 对文件的处理(图片、文字)</p><ol><li></li></ol><p>J. 提出通用模块</p><ol><li></li></ol><p>K. 规划文件打包位置</p><ol><li></li></ol><p>L. 热跟新(devServer)</p><ol><li><p>安装(yarn add webpack-dev-server@2.9.7 --dev)</p></li><li><p>配置devServer:{port: 8086}在output中添加  publicPath: '/dist/'</p></li><li><p>简化打包命令，在package.json中添加</p><p>&quot;scripts&quot;: {&quot;test&quot;: &quot;echo &quot;Error: no test specified&quot; &amp;&amp; exit 1&quot;,&quot;dev&quot;: &quot;node_modules/.bin/webpack-dev-server&quot;,&quot;dist&quot;: &quot;node_modules/.bin/webpack -p&quot;}</p></li><li><p>使用yarn run dev</p></li></ol><h5>4. React组件</h5><ol><li><p>注意的点</p><p>组件的return函数里面返回的HTML节点必须是一个</p><p>可以给外部使用的组件定义要暴露出去加export default<br>export default class ComponentHeader extends React.Component{}</p><p>入口的定义ReactDOM.render(&lt;Index/&gt;, document.getElementById('example'))<br>Index组件名, example需要加载的div的Id</p><p>组件可以通过参数的形式传递<br>var index = &lt;Index/&gt;; //使用时</p></li></ol><h4>5. 生命周期</h4><ol><li><p>两个函数</p><p>componentWillMount(){//将要加载}</p><p>componentDidMount(){//已经加载完成}</p></li></ol><h4>6. React属性与事件</h4><ol><li><p>state(属于组件的属性)用于设置自身的属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//初始化放在构造函数中</span><br><span class="line">constructor()&#123;</span><br><span class="line">    super(); //调用基类的所有的初始化方法</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        username : &apos;geely&apos;</span><br><span class="line">    &#125;;//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">&lt;p&gt;&#123;this.state.username&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p></li><li><p>props(属于组件的属性)用于接收外来的属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">传递参数: &lt;Index username=&quot;xiren&quot;&gt;</span><br><span class="line">接收参数：&lt;p&gt;&#123;this.state.username&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p></li></ol><h4>7. React样式</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; React 是一个用于构建用户界面的 javascript 库。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Java Web入门基础</title>
    <link href="http://yoursite.com/2018/07/03/2018/07/DynamicWeb/"/>
    <id>http://yoursite.com/2018/07/03/2018/07/DynamicWeb/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-08-01T16:26:13.999Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong></p><p><a id="more"></a></p><h5>1. SQLyog的使用</h5><h4>1.1 mysql的安装配置</h4><h4>1.2 SQLyog的安装与使用</h4><p><img src="/img/javaweb1.png" alt="banner"></p><pre><code>第一个框中的mysql是我自己取的名字(随便取)连接本地数据库的话localhost和3306不变用户名和密码是自己设置的</code></pre><h4>1.3 新建数据库</h4><p><img src="/img/javaweb2.png" alt="banner"></p><pre><code>左边空白处右击选择&quot;创建数据库&quot;--输入数据库名，   基字符集&quot;UTF-8&quot;，数据库排序规则默认.</code></pre><h5>2. Eclipse创建Web项目</h5><h4>2.1 tomcat的安装配置</h4><pre><code>下载，解压缩打开conf/server.xml，搜索8080，在最后加入URIEncoding=&quot;UTF-8&quot;，并保存配置环境变量，变量名CATALINA_HOME，变量值为tomcat路径(不要加;号)双击bin目录下的startup.bat执行浏览器输入localhost:8080双击bin目录下shutdown.bat停止服务</code></pre><h4>2.2</h4><h4>2.3 Eclipse常用操作</h4><pre><code>Ctrl+shift+F：格式化代码(首先要选中所有代码，其次输入法必须切换到英文)修改JSP文件编码：&quot;Windows&quot; - &quot;Preferences&quot; - &quot;Web&quot; - &quot;JSP Files&quot; - &quot;Encoding&quot;误关窗口重新打开：&quot;Windows&quot; - &quot;Show View&quot; - &quot;Other&quot;</code></pre><h4>2.4</h4><h4>2.5</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="java 后端" scheme="http://yoursite.com/tags/java-%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>好看常用的一些前端页面组件</title>
    <link href="http://yoursite.com/2018/06/24/2018/06/h-modules/"/>
    <id>http://yoursite.com/2018/06/24/2018/06/h-modules/</id>
    <published>2018-06-23T16:00:00.000Z</published>
    <updated>2018-08-22T09:23:01.079Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 在本篇文章中，我汇总了常见的一些在前端页面会用到的组件，比如登录框、搜索框、轮播图、基于flex的header和footer等。源代码都在<a href="https://github.com/xirenbunong" target="_blank" rel="noopener">我的github</a>中。</p><p><a id="more"></a></p><h4>1.好看常见的两个搜索框</h4><p><img src="/img/search1.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><p><img src="/img/search2.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>2.基于flex的header(页头)和footer(页脚)</h4><p><img src="/img/header.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a><img src="/img/footer.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>3.登录框</h4><p><img src="/img/login.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>4.基于Unslider插件的轮播图</h4><p><img src="/img/lbt.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>5.导航栏(带三角形)</h4><p><img src="/img/header-list.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>6.中部高度与宽度响适应布局</h4><p><img src="/img/sfy.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>7.根据数值显示</h4><p><img src="/img/zzt.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>8.有遮罩层的登录和注册</h4><p><img src="/img/shade.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><p>关键代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.shade&#123;</span><br><span class="line">    display: none;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background: rgba(0, 0, 0, 0.5);</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    z-index: 999;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    display: none;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 250px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin: -125px 0 0 -200px;</span><br><span class="line">    z-index: 1000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>9.图片滑动门</h4><p><img src="/img/slidoor1.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><h4>10.鼠标靠近图片变大</h4><p><img src="/img/bigimg.png" alt="banner"></p><p>More info: <a href="https://www.baidu.com" target="_blank" rel="noopener">预留链接</a></p><p>关键代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div img&#123;</span><br><span class="line">/* 动画时间 */</span><br><span class="line">transition: all 0.6s;</span><br><span class="line">&#125;</span><br><span class="line">div img:hover&#123;</span><br><span class="line">/* 鼠标靠近图片扩大倍数 */</span><br><span class="line">transform: scale(1.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 在本篇文章中，我汇总了常见的一些在前端页面会用到的组件，比如登录框、搜索框、轮播图、基于flex的header和footer等。源代码都在&lt;a href=&quot;https://github.com/xirenbunong&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的github&lt;/a&gt;中。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>大型项目webpack模板</title>
    <link href="http://yoursite.com/2018/06/03/2018/06/webpack-package/"/>
    <id>http://yoursite.com/2018/06/03/2018/06/webpack-package/</id>
    <published>2018-06-02T16:00:00.000Z</published>
    <updated>2018-07-11T14:35:27.128Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 在本篇文章中，我将webpack模板构建出来，方便快速搭建项目环境。源代码都在<a href="https://github.com/xirenbunong" target="_blank" rel="noopener">我的github</a>中。</p><p><a id="more"></a></p><h4>1.npm与webpack初始化</h4><p>1.npm init生成package.json文件，添加一些字段如description、author（和github远程仓库建立连接的话，git repository字段会自己有远程仓库地址）</p><p>2.npm install webpack -g安装webpack</p><p>3.npm install webpack@1.15.0 --save-dev在本地安装webpack</p><p>4.建立webpack.config.js文件粘贴进去modules相关部分（此目的是为了通过entry和output解决只有一个入口文件和一个出口文件的打包约束）</p><h4>2.webpack对脚本和样式的处理问题：</h4><p>dist是一个打包目录，可以随时删除，执行webpack即可再次生成</p><p>1.Js用什么loader加载？</p><p>2.怎么解决多个entry文件？<br>数组</p><p>3.怎么解决output需要分文件夹存放目标文件？<br>[name]</p><p>4.jquery引入方式？<br>npm install jquery --save-dev</p><p>5.如何提取出公共模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用webpack的CommonsChunkPlugin提取公共代码    </span><br><span class="line">在webpack.config.js文件的plugins加入   </span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(</span><br><span class="line">    name : &apos;commons&apos;,</span><br><span class="line">    filename : &apos;js/base.js&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>6.样式使用怎样的loader？<br>css-loader和style-loader</p><p>7.如何将css打包成单独的文件？<br>npm install extract-text-webpack-plugin --save-dev<br>如果出错 加上版本号@1.0.1</p><h4>3.webpack对html模板的处理HtmlWebpackPlugin</h4><p>1.将html也打包到dist文件夹下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev html-webpack-plugin    </span><br><span class="line">var HtmlWebpackPlugin   = require(&apos;html-webpack-plugin&apos;);    </span><br><span class="line">要明白各个参数的含义    </span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template    : &apos;./src/view/index.html&apos;,</span><br><span class="line">            filename    : &apos;view/indx.html&apos;,</span><br><span class="line">            inject      : true,</span><br><span class="line">            hash        : true,</span><br><span class="line">            trunks      : [&apos;common&apos;, &apos;index&apos;]</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p><p>2.解决每次jquery需要每次手动引入的问题<br>npm install html-loader --save-dev</p><h4>4.webpack对图片和字体的处理</h4><p>npm install url-loader --save-dev</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 在本篇文章中，我将webpack模板构建出来，方便快速搭建项目环境。源代码都在&lt;a href=&quot;https://github.com/xirenbunong&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的github&lt;/a&gt;中。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浏览器报错状态码汇总</title>
    <link href="http://yoursite.com/2018/06/01/2018/06/browser-num/"/>
    <id>http://yoursite.com/2018/06/01/2018/06/browser-num/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-07-05T05:34:12.995Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 当用户试图通过HTTP或文件传输协议(FTP)访问一台正在运行Internet信息服务(IIS)的服务器上的内容时，IIS返回一个表示该请求的状态的数字代码。该状态代码记录在IIS日志中，同时也可能在Web浏览器或FTP客户端显示。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。</p><p><a id="more"></a></p><h4>1.网页报错代码汇总</h4><p>100 Continue：初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</p><p>101 Switching Protocols：服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</p><p>102 Processing：由于一个WebDAV请求可能包含多个涉及文件操作的子请求，可能花费很长的时间才能完成请求。这个状态码是指，服务器已经收到了请求，正在处理请  求，但是还没有任何响应。这防止客户端超时中断、以为请求丢失。</p><p>103 checkpoint：用于可恢复的请求建议，以恢复中止的PUT或POST请求。</p><p>200：OK 一切正常，对GET和POST请求的应答文档跟在后面。</p><p>201 Created：服务器已经创建了文档，Location头给出了它的URL。</p><p>202 Accepted：已经接受请求，但处理尚未完成。</p><p>203 Non-Authoritative Information：文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。</p><p>204 No Content：没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</p><p>205 Reset Content：没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。</p><p>206 Partial Content：客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。</p><p>207 Multi-Status：随后的邮件正文是一个XML消息，可能包含许多单独的响应代码，这取决于有多少个子请求</p><p>208 Already ReportedDAV：binding的成员在之前针对这个请求的答复中已经被列举，不再被计入</p><p>226 IM Used：服务器已执行了对资源的请求，响应代表了对当前实例执行的一个或多个实例处理的结果</p><p>300 Multiple Choices：客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明</p><p>301 Moved Permanently：客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL</p><p>302 Found：类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”</p><p>出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user:http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307</p><p>303 See Other：类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）</p><p>304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文     档还可以继续使用</p><p>305 Use Proxy：客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）</p><p>306 Switch Proxy：该状态码不再被使用。最初意味着“后续请求应该使用指定的代理。</p><p>307 Temporary Redirect：和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才  能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请  求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新）</p><p>308 Permanent Redirect：这个请求和以后的请求都应该使用另一个URI来重复。307和308与302和301的行为相似，但是不允许HTTP方法出现变化。所以比如说，向永久重  定向的资源提交表单会继续顺利执行。</p><p>400 Bad Request：请求出现语法错误。</p><p>401 Unauthorized：客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的     Authorization头后再次发出请求。</p><p>402 Payment Required：专门留给将来使用。初衷是，该状态码可用作某种数字现金或微支付方案的一部分，但是这种情形还没有出现，所以该状态码不常使用。如果某个开       发人员超出了每日限制的请求数量，Google Developers API就使用该状态。</p><p>403 Forbidden：资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。</p><p>404 Not Found：无法找到指定位置的资源。这也是一个常用的应答。</p><p>405 Method Not Allowed：请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）</p><p>406 Not Acceptable：指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。</p><p>407 Proxy Authentication Required：类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）</p><p>408 Request Timeout：在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）</p><p>409 Conflict：通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）</p><p>410 Gone：所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知      的原因文档不可用。（HTTP 1.1新）</p><p>411 Length Required：服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）</p><p>412 Precondition Failed：请求头中指定的一些前提条件失败（HTTP 1.1新）。</p><p>413 Request Entity Too Large：目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1    新）。</p><p>414 Request URI Too Long：URI太长（HTTP 1.1新）。</p><p>415 Unsupported Media Type：请求实体的媒体类型不被服务器或资源支持。比如说，客户端上传image/svg+xml格式的图片，但是服务器需要图片使用一种不同的格式。</p><p>416 Requested Range Not Satisfiable：服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）</p><p>417 Expectation Failed：服务器无法满足Expect（期望）请求头字段的要求。</p><p>418 I'm a teapot：1998年定义的这个代码是传统的IETF愚人节笑话之一，在RFC2324：超文本咖啡壶控制协议（Hyper Text Coffee PotControl Protocol）中予以定义，但是          没有打算由实际的HTTP服务器来实施。RFC指定该状态码应该由请求的茶壶返回给现煮咖啡。该HTTP状态码用于一些网站中的复活节彩蛋，包括Google.com。</p><p>419 Authentication Timeout：419 Authentication Timeout不是HTTP标准的一部分，它表示以前有效的验证已到期失效。它用作替代401 Unauthorized的状态码，目的是为了有别于被拒绝访问特定服务器资源的以其他方式验证的客户端。</p><p>421 Misdirected Request：请求被指向到无法生成响应的服务器（比如由于连接重复使用）。</p><p>422 Unprocessable Entity：请求符合规范，但是由于语法错误，无法得到后续处理。</p><p>423 Locked：访问的资源被锁定。</p><p>424 Failed Dependency：请求因上一个请求失败而失败（比如PROPPATCH）。</p><p>426 Upgrade Required：客户端应该换成不同的协议，比如TLS/1.0，该协议已在Upgrade（升级）头字段里指定。</p><p>428 Precondition Required：原始服务器需要请求有条件。旨在防止出现“‘丢失更新’问题：当客户端GET资源的状态、修改状态，又PUT回给服务器，同时第三方在服务器上      修改状态，导致冲突。”</p><p>429 Too Many Requests：用户在指定的时间里发送了太多的请求。用于与速率限制方案结合使用。</p><p>431 Request Header Fields Too Large：由于单个头字段或者全部头字段太大，服务器不愿意处理请求。</p><p>451 Unavailable For Legal Reasons：在因特网草案“用于法律限制的资源的新HTTP状态码”中予以定义。旨在因法律原因而拒绝访问资源时使用，比如审查制度或政府要求的      禁止访问。</p><p>500 Internal Server Error：服务器遇到了意料不到的情况，不能完成客户的请求。</p><p>501 Not Implemented：服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</p><p>502 Bad Gateway：服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</p><p>503 Service Unavailable：服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。</p><p>504 Gateway Timeout：由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）</p><p>505 HTTP Version Not Supported：服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）</p><p>506 Variant Also Negotiates：对请求进行透明的内容协商导致循环引用。</p><p>507 Insufficient Storage：服务器无法存储完成请求所必须的内容。</p><p>508 Loop Detected：服务器在处理请求时检测到一个无限循环。</p><p>510 Not Extended：需要请求有额外的扩展内容，服务器才能处理请求。</p><p>511 Network Authentication Required：客户端需要验证以获得网络访问权。原本用于拦截用来控制网络访问的代理（比如，“强制门户网站”用来要求先同意服务条款，之后   才授予通过无线热点全面访问互联网的权限）。</p><p>非官方状态码</p><p>下列状态码并不由任何RFC指定，但被第三方服务用来提供语义错误响应或充分利用REST的错误响应：</p><p>420 Method Failure（Spring框架）：方法失效后，Spring框架使用的废弃响应。</p><p>420 Enhance Your Calm（Twitter）：当客户端的速率受到限制时，TwitterSearch and Trends API的版本1返回该状态码；版本1.1及以后版本改而使用429 Too Many Requests响应码。</p><p>450 Blocked by Windows Parental Controls（微软）：微软扩展代码。当Windows Parental Controls被开启，阻止对特定网页的访问时，显示该错误。</p><p>498 Invalid Token（Esri）：ArcGIS forServer返回的状态码。状态码498表明到期的令牌或其他的无效令牌。</p><p>499 Token Required（Esri）：ArcGIS forServer返回的状态码。状态码499表明需要令牌，但是令牌未提交。</p><p>509 Bandwidth Limit Exceeded（ApacheWeb Server/cPanel）：服务器已超过由服务器管理员指定的带宽；这常常被共享主机托管提供商用来限制客户的带宽。</p><h4>2.经常会用到的错误码（面试必备）</h4><p>200 - 服务器成功返回网页，客户端请求已成功。<br>302 - 对象临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>304 - 属于重定向。自上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br>401 - 未授权。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>404 - 未找到。服务器找不到请求的网页。<br>2xx - 成功。表示服务器成功地接受了客户端请求。<br>3xx - 重定向。表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。<br>4xx - 请求错误。这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>5xx - 服务器错误。表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 当用户试图通过HTTP或文件传输协议(FTP)访问一台正在运行Internet信息服务(IIS)的服务器上的内容时，IIS返回一个表示该请求的状态的数字代码。该状态代码记录在IIS日志中，同时也可能在Web浏览器或FTP客户端显示。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="转载" scheme="http://yoursite.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>java入门(面向对象)</title>
    <link href="http://yoursite.com/2018/05/20/2018/05/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/05/20/2018/05/java面向对象/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2018-07-18T14:30:49.564Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> Java作为面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。据IDC统计，Java在所有软件开发类人才的需求中，对Java工程师的需求曾达到全部需求量的50%以上。TIOBE指数显示，Java编程已经超过了20%的普及门槛，这意味着每五行源代码当中就有一行采用Java编写</p><p><a id="more"></a></p><h4>6.JAVA面向对象</h4><h3>6.1类和对象</h3><p>1.理解类、对象、对象的属性(有什么)、对象的方法(能做什么)</p><p>2.类的组成：属性和方法<br>定义类的步骤：<br>定义类名：public class 类名{  }（其中class为声明类的关键字，类名首字母大写）<br>编写类的属性：属性类型  属性名称；（0或多都可）<br>编写类的方法</p><h3>6.2构造方法</h3><p>1.构造方法：是定义在java类中的一个用来初始化对象的方法，它与类同名且没有返回值。<br>2.语句格式：public 类名(){}<br>3.构造方法可分为无参和有参。<br>4.当没有指定构造方法时系统会自动添加无参的构造方法。<br>5.当有指定构造方法时，无论是有参、无参的构造方法，都不会自动添加无参的构造方法。<br>6.构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择</p><h3>6.3静态static</h3><p>静态变量的访问可以不创建对象，<br>直接用 类名.静态变量 也可以创建对象用 “对象名.静态变量” 访问静态变量。<br>还可以通过改变 对象名.静态变量 来改变静态变量的值。<br>静态方法同理</p><h3>6.4封装</h3><p>6.4.1封装的步骤：</p><pre><code>1、修改属性的的可见性（设置为private）   2、创建set(接收值)和get(返回值)方法     3、在getter和setter方法中加入属性控制语句 </code></pre><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private float Screen;</span><br><span class="line">public float getScreen()&#123; </span><br><span class="line">    return Screen;</span><br><span class="line">    &#125;</span><br><span class="line">//无参返回，用get方法得到属性值</span><br><span class="line"></span><br><span class="line">public void setScreen(float newScreen)&#123;</span><br><span class="line">    //将形参值赋给变量</span><br><span class="line">    Screen = newScreen;</span><br><span class="line">&#125;</span><br><span class="line">//带参无返回，用ser方法给属性赋值</span><br></pre></td></tr></table></figure></p><p>6.4.2 This<br>this 关键字，代表当前对象。<br>this.属性   操作当前对象的属性<br>this.方法   操作当前对象的方法</p><p>6.4.3内部类</p><p>当内部类和外部类属性名相同时：<br>使用外部类类名.this.属性名  区别  内部属性名<br>没有冲突时，属性名即可访问外部类属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//外部类HelloWorld</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">    </span><br><span class="line">    //外部类的私有属性name</span><br><span class="line">    private String name = &quot;imooc&quot;;</span><br><span class="line">    </span><br><span class="line">    //外部类的成员属性</span><br><span class="line">    int age = 20;</span><br><span class="line">    </span><br><span class="line">//成员内部类Inner</span><br><span class="line">public class Inner &#123;</span><br><span class="line"></span><br><span class="line">        //内部类中的方法</span><br><span class="line">public void show() &#123; </span><br><span class="line">System.out.println(&quot;外部类中的name：&quot; + HelloWorld.this.name);</span><br><span class="line">System.out.println(&quot;内部类中的name：&quot; + name);</span><br><span class="line">System.out.println(&quot;外部类中的age：&quot; + age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">//测试成员内部类</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        //创建外部类的对象</span><br><span class="line">HelloWorld o = new HelloWorld (); </span><br><span class="line">        </span><br><span class="line">        //创建内部类的对象</span><br><span class="line">Inner inn = o.new Inner();             ;</span><br><span class="line">        </span><br><span class="line">        //调用内部类对象的show方法</span><br><span class="line">inn.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>6.5继承</h3><p>6.5.1继承的好处：</p><pre><code>子类拥有父类的所有属性(属性前面不能是private)和方法，实现代码复用.      </code></pre><p>6.5.2语法规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class 子类 extends 父类</span><br><span class="line">例如</span><br><span class="line">public class  Dog extends Animal&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>6.5.3方法的重写<br>为什么要方法重写?</p><pre><code>当父类的方法体满足不了子类的需求时, 子类的方法体重写例如人类有方法say(), 中国人类说中国话, 美国人类说美国话, 所以子类say()方法重写   </code></pre><p>在子类中重写的规则</p><pre><code>1、返回值类型2、方法名3、参数类型及个数都要与父类继承的方法相同</code></pre><p>6.5.4final</p><pre><code>final关键字： 表示“最终的”，即不可修改。final可以修饰类、方法、属性和变量1、修饰类：不允许被继承2、修饰方法：不允许被重写3、修饰属性：则该属性不会进行隐式初始化（不会自动初始化），需要手动初始化或者在构造方法中初始化4、修饰变量，即变量变为常量注意区别属性和变量(有无修饰符public等)</code></pre><p>6.5.5super</p><pre><code>为什么要使用super?     子类属性和方法值不同, 但是都要使用时, super.属性 | super.方法来调用父类属性或方法</code></pre><h3>6.6多态</h3><p>6.6.1 为什么要使用多态?</p><p>6.6.2 类型转换instanceof</p><p>6.6.3 抽象类abstract</p><pre><code>在父类中声明抽象方法名, 以分号结束, 在子类中声明方法体abstract class Animal { abstract void grow(); }public void grow(){方法体};</code></pre><p>6.6.4 接口implements<br>(为了描述两个不同类的对象之间相同的特征)</p><pre><code>修饰符 interface 接口名 [extends 父接口1，父接口2......]{零个到多个常量定义...零个到多个抽象方法的定义....}接口可以多继承, 即可以有多个父亲因为接口是被继承、被使用的关系, 所以一般修饰符是public</code></pre><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接口函数：</span><br><span class="line">public interface IPlaygame&#123;</span><br><span class="line">    //没有方法体</span><br><span class="line">    public void playGame();</span><br><span class="line">&#125;</span><br><span class="line">子类实现接口：</span><br><span class="line">public class SmartPhone extends Telphone implements()&#123;</span><br><span class="line">    public void playGame()&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>6.7异常与异常处理</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">//一些会抛出异常的方法</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">//处理该异常的代码块</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">//最终将要执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; Java作为面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。据IDC统计，Java在所有软件开发类人才的需求中，对Java工程师的需求曾达到全部需求量的50%以上。TIOBE指数显示，Java编程已经超过了20%的普及门槛，这意味着每五行源代码当中就有一行采用Java编写&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="java 后端" scheme="http://yoursite.com/tags/java-%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ajax全接触</title>
    <link href="http://yoursite.com/2018/05/16/2018/05/ajax/"/>
    <id>http://yoursite.com/2018/05/16/2018/05/ajax/</id>
    <published>2018-05-16T04:23:58.000Z</published>
    <updated>2018-07-15T12:13:07.099Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p><p><a id="more"></a></p><h3>1.XMLHttpRequest发送请求有两个方法：</h3><p>（1）open（method，url，async）</p><pre><code> method：发送请求方法； url：请求地址； async：请求同步/异步，默认值为true。</code></pre><p>（2）send（string）</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.open(&quot;GET&quot;,&quot;get.php&quot;,true);</span><br><span class="line">request.send();</span><br><span class="line"> </span><br><span class="line">request.open(&quot;POST&quot;,&quot;create.php&quot;,true);</span><br><span class="line">request.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-from-urlencoded&quot;);  //必须放在open和send中间。设置HTTP的头信息</span><br><span class="line">request.send(&quot;name=王二狗&amp;sex=男&quot;)</span><br></pre></td></tr></table></figure></p><h3>2.XML建立一个AJAX异步请求：</h3><ol><li>new一个XHR对象request</li><li>调用open()方法</li><li>send()一些数据</li><li>对过程进行监听来知道数据库是否响应，最后做一些事情</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var request=new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">request.open(&quot;GET&quot;,&quot;get.php&quot;,true);</span><br><span class="line"></span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">request.onreadystatechange=function()&#123;</span><br><span class="line"></span><br><span class="line">if(request.readyState===4&amp;&amp;request.status===200)&#123;</span><br><span class="line"></span><br><span class="line">//做一些事情.request.responseText&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>JSON格式示例</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;staff&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot; : &quot;洪七公&quot;,</span><br><span class="line">            &quot;age&quot; : &quot;70&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot; : &quot;郭靖&quot;,</span><br><span class="line">            &quot;age&quot; : &quot;35&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot; : &quot;黄蓉&quot;,</span><br><span class="line">            &quot;age&quot; : &quot;30&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var jsondata = &apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七公&quot;,&quot;age&quot;:&quot;70&quot;&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:&quot;35&quot;&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:&quot;30&quot;&#125;]&#125;&apos;;</span><br><span class="line"></span><br><span class="line">var jsonobj = JSON.parse(jsondata);</span><br><span class="line"></span><br><span class="line">alert(jsonobj.staff[0].name);</span><br><span class="line"></span><br><span class="line">效果：弹出“洪七公”</span><br></pre></td></tr></table></figure></p><h3>用Jquery实现Ajax</h3><pre><code>jQuery.ajax([settings])&lt;br&gt;1:type:类型，“post”或“get”,默认为“get”；&lt;br&gt;2：url:发送请求的地址&lt;br&gt;3：data：是一个对象，连同请求发送到服务器的数据&lt;br&gt;4：datatype：预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包MIME信息来智能判断，一般我们采用json格式，可以设置为json（可以不指定）5：success：是一个方法，请求成功后的回调函数，传入返回后的数据，以及包含成功代码的字符串6：error：是一个方法，请求失败时调用此函数，传入XMLHttpRequest对象</code></pre><p>示例代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line"></span><br><span class="line">    type:&apos;GET/POST&apos;,</span><br><span class="line"></span><br><span class="line">    url:&apos;service.php?number=&apos; + $(&apos;#id&apos;).val(),</span><br><span class="line"></span><br><span class="line">    dataType:&apos;json&apos;,</span><br><span class="line"></span><br><span class="line">    // 如果是post方式还有个data,采用json模式数据</span><br><span class="line"></span><br><span class="line">    data:&#123;</span><br><span class="line"></span><br><span class="line">        name:$(&apos;#id&apos;).val(),</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    success:function()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">    error:function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>java入门(基础知识)</title>
    <link href="http://yoursite.com/2018/05/07/2018/05/java%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/05/07/2018/05/java入门/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-07-13T12:43:05.001Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> Java作为面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。据IDC统计，Java在所有软件开发类人才的需求中，对Java工程师的需求曾达到全部需求量的50%以上。TIOBE指数显示，Java编程已经超过了20%的普及门槛，这意味着每五行源代码当中就有一行采用Java编写</p><p><a id="more"></a></p><h4>1.安装配置jdk</h4><p>一直点击下一步，安装目录可以自定义，但是要记住自己的安装目录在哪。<br>然后配置环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.JAVA_HOME  配置jdk的安装路径</span><br><span class="line">jdk的安装目录</span><br><span class="line">2.CLASS_PATH 配置类库文件的位置(.代表当前路径 ;代表隔开)</span><br><span class="line">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br><span class="line">3.PATH 配置jdk命令文件的位置</span><br><span class="line">%JAVA_HOME%\bin;</span><br></pre></td></tr></table></figure></p><p>win+R,输入cmd，回车，界面输入java -version，显示版本即为正确。</p><h4>2.安装IDEA</h4><p>一直下一步就可以了<br>打开后<br>1.选择是否有自己的setting<br>2.登录自己的账号或者试用30天<br>3.选择界面风格<br>4.一直next就可以了</p><h4>3.记事本创建HelloWorld.java</h4><p>1.记事本创建HelloWorld.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;HelloWorld!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码的HelloWorld要与文件名HelloWorld相同</span><br><span class="line">public static void是固定的</span><br></pre></td></tr></table></figure></p><p>2.使用javac命令编译为字节码文件HelloWorld.class<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd中执行 javac HelloWorld.java</span><br><span class="line">出现HelloWorld.class</span><br></pre></td></tr></table></figure></p><p>3.执行HelloWorld<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在cmd中执行java HelloWorld</span><br></pre></td></tr></table></figure></p><h4>4.使用eclipse创建java项目</h4><h3>4.1.创建java项目</h3><p>new-java project-name</p><h3>4.2.创建程序包</h3><p>new-package-name<br>注意包名为域名的反向</p><h3>4.3.编写java源程序</h3><p>new-class-name<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2与3可以合并为  new-class-name/package</span><br><span class="line">name: 文件名   package: com.项目名</span><br></pre></td></tr></table></figure></p><h3>4.4.运行java源程序</h3><p>空白处右击-Run As-java application<br>或者点击导航栏的运行按钮</p><h4>5.JAVA基本语法</h4><h3>5.1.java的变量需要指定数据类型,先声明再使用</h3><p>整型int a = 1;<br>浮点型float b = 175.2f;<br>字符型char c = 'A';<br>字符串String cc = &quot;AAA&quot;;<br>布尔型boolean d = true;</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于 float 型和 double 型的区别，以及 char 型和 String 型的不同</span><br></pre></td></tr></table></figure></p><h3>5.2.强制转换</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a = 12.5;</span><br><span class="line">int b = (int)a;</span><br><span class="line">//b = 12</span><br></pre></td></tr></table></figure></p><h3>5.3.Java常量</h3><p>语法：final 常量名 = 值;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">应用场景：</span><br><span class="line">final double PI = 3.14;</span><br></pre></td></tr></table></figure></p><h3>5.4.运算符</h3><p>自增++与自减--处在变量前后位置的不同，结果的不同</p><h3>5.5.Java 常用的 3 种循环： while 、 do...while 、 for</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while语法：</span><br><span class="line">while(判断条件)&#123;</span><br><span class="line">    循环操作</span><br><span class="line">&#125;</span><br><span class="line">执行过程：</span><br><span class="line">&lt; 1 &gt;、 判断 while 后面的条件是否成立( true / false )</span><br><span class="line">&lt; 2 &gt;、 当条件成立时，执行循环内的操作代码 ，然后重复执行&lt; 1 &gt;、&lt; 2 &gt;， 直到循环条件不成立为止</span><br><span class="line">特点：先判断，后执行</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do..while语法：</span><br><span class="line">do&#123;</span><br><span class="line">    循环操作</span><br><span class="line">&#125;while(判断条件);</span><br><span class="line">执行过程：</span><br><span class="line">&lt;1&gt;、 先执行一遍循环操作，然后判断循环条件是否成立</span><br><span class="line">&lt;2&gt;、 如果条件成立，继续执行&lt; 1 &gt; 、&lt; 2 &gt;，直到循环条件不成立为止</span><br><span class="line">特点： 先执行，后判断</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for语法：</span><br><span class="line">for(循环变量初始值;循环条件;循环变量变化)&#123;</span><br><span class="line">    循环操作</span><br><span class="line">&#125;</span><br><span class="line">执行过程：</span><br><span class="line">&lt;1&gt;、 执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次</span><br><span class="line">&lt;2&gt;、 进行循环条件的判断，如果条件为 true ，则执行循环体内代码；如果为 false ，则直接退出循环</span><br><span class="line">&lt;3&gt;、 执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断</span><br><span class="line">&lt;4&gt;、 依次重新执行&lt; 2 &gt;、&lt; 3 &gt;、&lt; 4 &gt;，直到退出循环</span><br><span class="line">特点：相比 while 和 do...while 语句结构更加简洁易读</span><br></pre></td></tr></table></figure></p><p>Java循环跳转语句之 break 与 continue</p><h3>5.6.java获取用户输入</h3><p>Scanner类位于java.util包中，使用时需要导入此包<br>步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.导入java.util.Scanner : 在代码开头的地方输入import java.util.Scanner;  </span><br><span class="line">2.创建Scanner对象 : main中输入Scanner input = new Scanner(System.in);  </span><br><span class="line">System.out.println(&quot;请输入&quot;);   </span><br><span class="line">3.接受并保存用户输入的值 ：用变量a来接收值int a = input.nextInt();</span><br></pre></td></tr></table></figure></p><h3>5.7.数组</h3><p>7.1、 声明数组<br>语法：  数据类型[ ] 数组名；<br>或者   数据类型 数组名[ ]；int[] a;</p><p>7.2、 分配空间<br>语法：  数组名 = new  数据类型 [ 数组长度 ];<br>a = new int[5];<br>或者合并为<br>int[] a = new int[5];</p><p>7.3、 赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[ ] a = new int[5];需要指定长度  </span><br><span class="line">int[] a = new int[]&#123;1,2,3,5,8&#125;;不能指定长度  </span><br><span class="line">int[] a = &#123;1,2,3,5,8&#125;;最简单的数组声明加赋值方式</span><br></pre></td></tr></table></figure></p><p>7.4、 使用Arrays 类操作 Java 中的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">排序  Arrays.sort(数组名);</span><br><span class="line">将数组转换为字符串  System.out.println(Arrays.toString(数组名))；</span><br></pre></td></tr></table></figure></p><p>7.5、 使用 foreach 操作数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(类型 参数 : 数组名)&#123;</span><br><span class="line">    System.out.println(参数);</span><br><span class="line">&#125;</span><br><span class="line">例：</span><br><span class="line">// 定义一个整型数组，保存成绩信息</span><br><span class="line">int[] scores = &#123; 89, 72, 64, 58, 93 &#125;;</span><br><span class="line">// 使用foreach遍历输出数组中的元素</span><br><span class="line">for ( int score : scores) &#123;</span><br><span class="line">System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.6、 二位数组<br>两种形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type[][] a = new type[3][4];必须有数值</span><br><span class="line">type[][] a = &#123; , , &#125;;</span><br></pre></td></tr></table></figure></p><h3>5.8.方法</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义方法</span><br><span class="line">访问修饰符 返回值类型 方法名（参数列表）&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建对象</span><br><span class="line">类名 对象名 = new 类名()</span><br><span class="line"></span><br><span class="line">调用方法</span><br><span class="line">对象名.方法名()</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">带参带返回值的方法</span><br><span class="line">主函数&#123;</span><br><span class="line">    创建对象同时传参;</span><br><span class="line">    操作该对象;</span><br><span class="line">&#125;</span><br><span class="line">方法函数&#123;</span><br><span class="line">    接收参数，执行具体方法;</span><br><span class="line">    返回参数给主函数的对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; Java作为面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。据IDC统计，Java在所有软件开发类人才的需求中，对Java工程师的需求曾达到全部需求量的50%以上。TIOBE指数显示，Java编程已经超过了20%的普及门槛，这意味着每五行源代码当中就有一行采用Java编写&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="java 后端" scheme="http://yoursite.com/tags/java-%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/05/06/2018/05/zhengze/"/>
    <id>http://yoursite.com/2018/05/06/2018/05/zhengze/</id>
    <published>2018-05-05T16:00:00.000Z</published>
    <updated>2018-07-05T05:07:46.445Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 在编写处理字符串的程序或网页时, 经常会有查找符合某些复杂规则的字符串的需要, 正则表达式就是用于描述这些规则的工具. 换句话说, 正则表达式就是记录文本规则的代码.</p><p><a id="more"></a></p><h4>1.思维导图</h4><p>单击图片打开可下载</p><p><img src="/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" alt="banner"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 在编写处理字符串的程序或网页时, 经常会有查找符合某些复杂规则的字符串的需要, 正则表达式就是用于描述这些规则的工具. 换句话说, 正则表达式就是记录文本规则的代码.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浅谈javascript难点</title>
    <link href="http://yoursite.com/2018/05/02/2018/05/js7/"/>
    <id>http://yoursite.com/2018/05/02/2018/05/js7/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-05-16T13:50:34.291Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> JavaScript 是世界上最流行的编程语言。这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</p><p><a id="more"></a></p><h4>1.函数</h4><p>为什么要创建对象?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全局变量命名太多可能会造成命名冲突, 放在一个对象下好整合</span><br></pre></td></tr></table></figure></p><p>为什么要使用函数?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以复用代码、维护性高、可读性高</span><br></pre></td></tr></table></figure></p><p>为什么要利用函数也是对象的性质给其添加属性, 并赋值为函数?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为这样可以将数值缓存下来</span><br><span class="line">例:</span><br><span class="line">函数名.属性 = function(参数)&#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么要将对象作为参数传入函数?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为函数调用传入实参时(例: 函数名(实参1,实参2,...,实参n))</span><br><span class="line">若参数个数太多, 则实参必须与形参一一对应, 容易出错, 并且有</span><br><span class="line">可选参数时, 可以不传.</span><br><span class="line">使用对象做形参, 只写一个, 例:</span><br><span class="line">function 函数名(对象X)&#123;</span><br><span class="line">    var 对象Y = &#123;&#125;;</span><br><span class="line">    对象Y.属性1 = 对象X.属性1;</span><br><span class="line">    对象Y.属性2 = 对象X.属性2;</span><br><span class="line">    对象Y.属性3 = 对象X.属性3;</span><br><span class="line">    对象Y.属性4 = 对象X.属性4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么要将对象或者函数作为函数返回值?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这样就可以返回多个值</span><br><span class="line">return &#123;</span><br><span class="line">    name : &apos;xm&apos;,</span><br><span class="line">    age  : 18</span><br><span class="line">&#125;</span><br><span class="line">return function()&#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>1.闭包</h4><p>为什么要使用闭包?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为函数内定义的变量(局部变量)不能在函数体外访问, 想要将该变量在函数体外访问到, </span><br><span class="line">需要在函数内部再定义函数B, 通过B函数函数才能在函数外访问到改变量, 进行操作.</span><br></pre></td></tr></table></figure></p><p>闭包的优缺点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点: 有利于封装, 可以访问局部变量.</span><br><span class="line">缺点：内存占用严重浪费, 会造成内存泄漏.</span><br></pre></td></tr></table></figure></p><h4>2.原型</h4><p>为什么要使用原型?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使方法的属性可以在方法外部去定义</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    空;</span><br><span class="line">&#125;</span><br><span class="line">代码示例:</span><br><span class="line">test.prototype.color = &quot;red&quot;;</span><br><span class="line">test.prototype.showInfo = function()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">或者(json格式):</span><br><span class="line">test.prototype = &#123;</span><br><span class="line">    color: &quot;red&quot;;</span><br><span class="line">    showInfo: function()&#123;</span><br><span class="line">        alert(this.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">备注:</span><br><span class="line">1.prototype是每个函数自带的一个属性</span><br><span class="line">2.混合模式 = 构造 + 原型</span><br></pre></td></tr></table></figure></p><h4>3.封装</h4><p>为什么要使用封装?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将局部变量、方法隐藏在接口中, 通过对外的接口来访问该属性或对象</span><br></pre></td></tr></table></figure></p><h4>4.单例模式</h4><p>为什么要使用单例模式?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个类只有一个实例, 如</span><br><span class="line">①公司事件：员工若干, 而老板只有一个</span><br><span class="line">②皇宫事件：大臣若干, 而皇帝只有一个</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; JavaScript 是世界上最流行的编程语言。这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>响应式开发（二）Bootstrap</title>
    <link href="http://yoursite.com/2018/05/01/2018/05/Bootstrap/"/>
    <id>http://yoursite.com/2018/05/01/2018/05/Bootstrap/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-07-31T12:40:54.971Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> Bootstrap, 来自 Twitter, 是目前最受欢迎的前端框架.Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的, 它简洁灵活, 使得 Web 开发更加快捷.</p><p><a id="more"></a></p><h4>概览</h4><h4>1.开发环境的搭建</h4><h3>1.1 环境安装</h3><p>Bootstrap CDN 推荐</p><pre><code>&lt;!-- 新 Bootstrap 核心 CSS 文件 --&gt;&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- 可选的Bootstrap主题文件（一般不使用） --&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot;&gt;&lt;/script&gt;&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>你还可以使用以下的 CDN 服务：<br>国内推荐使用 : https://www.staticfile.org/<br>国际推荐使用：https://cdnjs.com/</p><h3>1.2 代码模板</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;    </span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4>2. 主要内容</h4><h3>2.1 栅格系统</h3><h3>2.2 排版样式(标题、文本)</h3><h3>2.3 列表样式(无序、有序)</h3><h3>2.4 按钮样式</h3><h3>2.5 表格、表单样式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; Bootstrap, 来自 Twitter, 是目前最受欢迎的前端框架.Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的, 它简洁灵活, 使得 Web 开发更加快捷.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="响应式开发" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发入门</title>
    <link href="http://yoursite.com/2018/04/20/2018/04/wechatApp/"/>
    <id>http://yoursite.com/2018/04/20/2018/04/wechatApp/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-07-16T12:02:41.602Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 2017年1月9日, 微信小程序正式上线. 微信小程序无需下载, 无需安装, 即扫即用, 属于轻量型应用.小程序是一种新的开放能力, 开发者可以快速地开发一个小程序. 小程序可以在微信内被便捷地获取和传播, 同时具有出色的使用体验.</p><p><a id="more"></a></p><h4>1.概览</h4><h4>2.环境搭建</h4><h3>2.1申请APPID</h3><p>打开:<a href="https://developers.weixin.qq.com/miniprogram/dev/index.html?t=2018712" target="_blank" rel="noopener">微信开发者文档</a><br>点击 <a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">注册</a>, 申请APPid<br>注册成功后, 在<a href="https://mp.weixin.qq.com" target="_blank" rel="noopener">登录</a>之后, 在&quot;开发&quot;--&quot;基本配置&quot;即可获取APPid</p><h3>2.2下载开发者工具</h3><p>进入<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=2018712" target="_blank" rel="noopener">下载页面</a>下载开发者工具</p><h4>3.创建第一个小程序</h4><p>&quot;新建项目&quot;--&quot;项目目录&quot;--&quot;APPID&quot;--&quot;项目名称&quot;--&quot;点击确定&quot;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 2017年1月9日, 微信小程序正式上线. 微信小程序无需下载, 无需安装, 即扫即用, 属于轻量型应用.小程序是一种新的开放能力, 开发者可以快速地开发一个小程序. 小程序可以在微信内被便捷地获取和传播, 同时具有出色的使用体验.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="wechat" scheme="http://yoursite.com/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>响应式开发（一）Foundation</title>
    <link href="http://yoursite.com/2018/04/16/2018/04/foundation/"/>
    <id>http://yoursite.com/2018/04/16/2018/04/foundation/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-09T07:09:06.147Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 号称是世界上最先进的响应式前端框架, Foundation是一个易用、强大而且灵活的框架, 用于构建基于任何设备上的Web应用. 提供多种Web上的UI 组件, 如表单、按钮、 标签等.</p><p><a id="more"></a></p><h4>概览</h4><h4>1.开发环境的搭建</h4><h3>1.1 安装Git</h3><p>关于git的下载地址, 安装方式, 在本人博客<a href="">git入门基础</a>中有具体讲解.</p><h3>1.2 安装Node.js</h3><p>查看node版本, 不能小于6.0.0(关于如何安装或者跟新node, 在本人博客&quot;<a href="https://xirenbunong.github.io/2018/02/28/2018/03/hexo%20pro/" target="_blank" rel="noopener">手把手教你使用Hexo打造个人博客</a>&quot;中有)<img src="/img/foundation1.png" alt="banner"></p><h3>1.3 下载Foundation</h3><p>npm install --global foundation-cli全局安装, 所以--global</p><p>foundation new会出现三个问题:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.安装web, APP, Email(选择一项即可);</span><br><span class="line">2.项目名称;</span><br><span class="line">3.直接回车即可</span><br></pre></td></tr></table></figure></p><p>安装完成后显示如下, 则表示成功, Ctrl+C退出, 否则看下文解决方法<br><img src="/img/foundation2.png" alt="banner"></p><p>如果遇到以下问题, 删除文件, 然后再npm install --save, 然后foundation new安装一次, 即可解决:<br><img src="/img/foundation3.png" alt="banner"></p><h3>1.4 启动服务预览</h3><p>cd进入到项目根目录下(非常重要！！！), 执行npm start启动服务, 然后打开文件所在目录, 在根目录下有index.html, 浏览器打开即可<br><img src="/img/foundation3.png" alt="banner"></p><h4>2.基本概念与常用工具类</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过对列添加属性来实现效果</span><br><span class="line">column: 列、 row:行.</span><br></pre></td></tr></table></figure></p><h3>2.1 了解栅格布局</h3><p>原理: 将一行分为12列进行布局, 三种尺寸：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">small: &lt; 640px</span><br><span class="line">medium: 640px &lt; &amp;&amp; &lt; 1024px</span><br><span class="line">large: &gt; 1024px</span><br></pre></td></tr></table></figure></p><h3>2.2 Flex布局</h3><p>1&gt; 不指定列宽, 则自动填充剩余位置<br>2&gt; shrink根据内容缩减列宽<br>3&gt; 可以设置对齐方式<br>4&gt; 可以控制不同尺寸下盒子排列顺序</p><h3>2.3 Visibility Classes(盒子的显示与隐藏)</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&gt;show-for-medium</span><br><span class="line">在中屏或大于中屏的屏幕上显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2&gt;show-for-large</span><br><span class="line">在大屏或大于大屏的屏幕上显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3&gt;show-for-small-only</span><br><span class="line">仅在小屏中显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4&gt;show-for-medium-only</span><br><span class="line">仅在中屏中显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5&gt;show-for-large-only</span><br><span class="line">仅在大屏中显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6&gt;hide-for-medium</span><br><span class="line">在中屏或大于中屏的屏幕上隐藏</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7&gt;hide-for-large</span><br><span class="line">在大屏或大于大屏的屏幕上隐藏</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8&gt;hide-for-small-only</span><br><span class="line">仅在小屏中隐藏</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9&gt;hide-for-medium-only</span><br><span class="line">仅在中屏中隐藏</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10&gt;hide-for-large-only</span><br><span class="line">仅在大屏中隐藏</span><br></pre></td></tr></table></figure></p><h3>2.4 Float classes(盒子对齐)</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&gt;float-left 居左显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&gt;float-right 居右显示</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3&gt;float-center 居中显示</span><br></pre></td></tr></table></figure></p><h3>2.5 Helper Classes</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&gt;text-left 文字居左对齐</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&gt;text-right 文字居右对齐</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3&gt;text-center 文字居中对齐</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4&gt;text-justify 文字两端对齐</span><br></pre></td></tr></table></figure></p><h4>3.多媒体组件</h4><h3>3.1 Badeg(徽章图标)</h3><h3>3.2 Flex Video(可伸缩视频)</h3><h3>3.3 Label(标签)</h3><h3>3.4 Orbit(轮播图)</h3><h3>3.5 Progress Bar(进度条)</h3><h3>3.6 Thumbnail(缩略图)</h3><h3>3.7 Tooltip(提示框)</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 号称是世界上最先进的响应式前端框架, Foundation是一个易用、强大而且灵活的框架, 用于构建基于任何设备上的Web应用. 提供多种Web上的UI 组件, 如表单、按钮、 标签等.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="响应式开发" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>响应式开发（题外篇）Flex布局</title>
    <link href="http://yoursite.com/2018/04/15/2018/04/flex/"/>
    <id>http://yoursite.com/2018/04/15/2018/04/flex/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-07-05T09:38:44.963Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> 2009年, W3C提出了一种新的方案—-Flex布局, 可以简便、完整、响应式地实现各种页面布局. Flex 是 Flexible Box 的缩写, 意为&quot;弹性布局&quot;, 用来为盒状模型提供最大的灵活性.任何一个容器都可以指定为Flex 布局.</p><p><a id="more"></a></p><h4>概览</h4><p><img src="/img/flex.jpg" alt="banner"></p><h4>1.1一般使用格式(套路)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: flex;  </span><br><span class="line">flex-direction: row;  </span><br><span class="line">justify-content:center;   </span><br><span class="line">align-items:flex-end</span><br></pre></td></tr></table></figure></p><h4>1.2基本概念</h4><h4>2.1父元素属性</h4><p>flex-direction主轴的方向<br>justify-content主轴上的对齐方式<br>align-items侧轴方向上的对齐方式<br>flex-wrap决定项目在一行排不下的情况下是否换行<br>flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap<br>align-content在侧轴方向上有额外空间时，如何每排布一行，当容器只有一行时，它不起作用</p><h4>2.2子元素属性</h4><p>order定义项目的排列顺序，数值越小排列越靠前，默认为0，可能的值为任意整数。<br>flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间也不放大。<br>flex-shrink定义了项目的缩小比例，默认为1，即如果空间不足该项目将缩小。<br>flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main-size）。<br>flex是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>align-self允许单个项目有与其他项目不一样的侧轴对齐方式，可覆盖align-items属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 2009年, W3C提出了一种新的方案—-Flex布局, 可以简便、完整、响应式地实现各种页面布局. Flex 是 Flexible Box 的缩写, 意为&amp;quot;弹性布局&amp;quot;, 用来为盒状模型提供最大的灵活性.任何一个容器都可以指定为Flex 布局.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="响应式开发" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>git入门基础</title>
    <link href="http://yoursite.com/2018/04/06/2018/04/git/"/>
    <id>http://yoursite.com/2018/04/06/2018/04/git/</id>
    <published>2018-04-06T04:23:58.000Z</published>
    <updated>2018-07-22T14:02:04.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> Git 是一个为了更好地管理 Linux 内核开发而创立的分布式版本控制和软件配置管理软件. 国内外知名 Git 代码托管网站有： GitHub.com Coding.net code.csdn.net ...</p><p><a id="more"></a></p><h3>1.git介绍</h3><p>新知识扑面而来的时候，可能会绝望，痛苦。但是不要放弃，没有人一生下来就会这些东西的，慢慢来，想学的，总会学会。首先说一下git，github，gitbash的区别。</p><p>git主要用于开发项目，因为它采用分布式。github是一个托管平台，就是一个放你代码的网站，从个人角度来说是防止你在本地的文件丢失，从团队角度来讲是便于团队开发，因为大家都能根据项目地址查看下载文件代码。gitbash是软件git自带的命令行工具，类似cmd，可以在命令行中输入命令快速操作文件。</p><h3>2.git安装与配置</h3><p>1.先git的安装，一直默认next安装就可以了2.git的配置文件.gitconfig放在C盘User/用户名/文件夹下，使用vim .gitconfig3.将配置项敲入即可4.node的安装，一直默认next安装就可以了</p><h3>3.git与远程仓库的联系</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd是用来进入某个目录的，白色的字是自己打的（前面那个美元符号是自动生成的），然后现在就进入了我们要上传路径的目录下。  </span><br><span class="line">输入git init，这个意思是在当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹）  </span><br><span class="line">输入git add.，这个是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把.换成这个特定的文件名即可。  </span><br><span class="line">rm -rf 文件名/文件夹  是删除  </span><br><span class="line">mkdir 文件名/文件夹  是创建文件夹</span><br><span class="line">vim 文件  是编辑文件</span><br></pre></td></tr></table></figure></p><p>1.mkdir test创建文件夹<br>2.cd test进入文件夹<br>3.git init初始化本地仓库，多了一个.git文件夹，通过ls -a可以查看<br>4.在test文件夹下即可加入项目文件（通过git status查看状态），使用命令git add或者git add .（.代表所有文件，点前面有空格）添加到仓库<br>5.通过git commit -m “注释”将项目提交到仓库</p><h3>4.生成ssh key</h3><p>1.通过命令ssh-keygen -t rsa -C &quot;m18791744718@163.com&quot;创建本地密钥（gitbash打开位置没有要求）<br>2.生成的密钥在C盘User/用户名/下的.ssh文件夹中<br>3.在github上添加密钥，然后创建项目，记得勾选readme<br>4.将本地仓库与github仓库相关联，使用命令 git remote add origin git@github.com:xirenbunong/test7-3.git，在origin后面的是ssh方式复制的仓库地址(把当前文件夹和git仓库的文件夹对应起来)</p><h3>5.某个项目与本地仓库之间如何联系</h3><p>1.在github上创建该项目，然后本地如果没有密钥，则在本地通过命令ssh key来配置<br>2.如果本地已经有密钥，则在github上打开项目，找到setting，添加上该项目的密钥（分清楚全局的密钥和项目的密钥）<br>3.通过git clone可以测试得到是否连接成功<br>4.git init<br>5.git add .<br>6.git commit -m &quot;说明&quot;<br>7.git remote add origin git@github.com:xirenbunong/WebHtml_Modules.git<br>8.git push origin master</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to git@github.com:WAng91An/TEST2.git的错。</span><br><span class="line">不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：</span><br><span class="line"></span><br><span class="line">$ git pull --rebase origin master</span><br><span class="line"> 这时你再push就能成功了</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b pro_v1.0  切换分支到V1.0版本的分支 -b参数表示该分支是新建的</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; Git 是一个为了更好地管理 Linux 内核开发而创立的分布式版本控制和软件配置管理软件. 国内外知名 Git 代码托管网站有： GitHub.com Coding.net code.csdn.net ...&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门基础</title>
    <link href="http://yoursite.com/2018/04/05/2018/04/webpack/"/>
    <id>http://yoursite.com/2018/04/05/2018/04/webpack/</id>
    <published>2018-04-05T04:23:58.000Z</published>
    <updated>2018-07-05T11:55:41.870Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要:</strong> webpack是一个前端资源加载打包工具。让前端工程模块化，让我们可以把复杂的程序细化为一个一个小的文件;根据模块间的依赖关系，生成对应的静态资源。</p><p><a id="more"></a></p><h3>1.核心概念</h3><p>·Entry·Output·Loaders·Plugins 打包优化和压缩</p><p>名词·Chunk·Bundle·Module模块之间的依赖关系是由require(commonjs规范)或import(es6规范)实现的。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预留</span><br></pre></td></tr></table></figure></p><h3>2.webpack.config.js配置文件各项说明</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预留</span><br></pre></td></tr></table></figure></p><h3>3.git与node安装</h3><h3>4.git与远程仓库的联系</h3><h3>5.生成ssh key</h3><h3>6.某个项目与本地仓库之间如何联系</h3><h3>7.安装webpack</h3><p>1.npm install webpack -g即可2.在本地环境上装一个webpack依赖，防止在部署上与本地的依赖版本不一致造成错误，使用npm install webpack@1.15.0 --save-dev</p><h3>8.package.json文件说明</h3><p>·name：项目的名字·version：项目的版本号·scripts：项目不同阶段的命令</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例 &quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;test&quot;: &quot;node test.js&quot;</span><br><span class="line">    &quot;start&quot;: &quot;node cluster/master.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">执行npm test = node test.js</span><br><span class="line">执行npm start = node cluster/master.js</span><br></pre></td></tr></table></figure></p><p>.dependencies：{&quot;bluebired&quot;：&quot;^3.3.4&quot;}</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; webpack是一个前端资源加载打包工具。让前端工程模块化，让我们可以把复杂的程序细化为一个一个小的文件;根据模块间的依赖关系，生成对应的静态资源。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
</feed>
